#N canvas 400 83 719 454 10;
#X text 41 -19 click here;
#X obj 23 -17 tgl 15 0 empty empty empty 0 -6 0 8 -24198 -1 -1 1 1
;
#X obj 31 251 #out window;
#X text 48 92 this is the feedback loop;
#X obj 123 0 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X obj 141 -1 for 0 10 1;
#X obj 263 53 loadbang;
#X obj 141 73 #store;
#X obj 141 19 bng 15 250 50 0 empty empty empty 0 -6 0 8 -262144 -1
-1;
#X obj 31 291 print;
#X obj 31 271 fps detailed;
#X obj 31 113 fork;
#X text 159 19 next;
#N canvas 0 0 450 210 game 0;
#X obj 28 64 inlet matrix;
#X obj 28 141 outlet matrix;
#X text 18 14 this part at the left defines the rule of the game (this
is my own rewriting of the rules. it is equivalent to the original
but faster to compute.);
#X obj 28 83 # << (b # 1);
#X obj 28 103 #convolve (3 3 b # 0 0 0 0 1) \, op >> \, seed (b # -5)
;
#X obj 28 122 # < (b # 3);
#X connect 0 0 3 0;
#X connect 3 0 4 0;
#X connect 4 0 5 0;
#X connect 5 0 1 0;
#X restore 31 72 pd game of life;
#X text 260 20 init with a random map;
#X text 262 35 10% white dots;
#X text 33 179 convert this 1-bit matrix to standard RGB \; 1 becomes
-1 becomes 255 \, but 0 stays 0;
#X obj 23 15 metro 5;
#X obj -15 339 cnv 15 780 30 empty empty empty 20 12 0 14 -200249 -66577
0;
#X text -7 346 GridFlow 0.8.0;
#X text -7 346 GridFlow 0.8.0;
#X obj -13 -85 cnv 15 780 30 empty empty empty 20 12 0 14 -233017 -66577
0;
#X text 0 -85 game_of_life.pd;
#X text 0 -72 Copyright 2001 Mathieu Bouchard;
#X obj 263 97 # rand (b #);
#X obj 263 119 # == (b # 0);
#X msg 263 75 240 320 b # 10;
#X obj 31 209 # inv+ (b # 0);
#X obj 31 230 #outer ignore (3 b #);
#X connect 1 0 17 0;
#X connect 2 0 10 0;
#X connect 4 0 5 0;
#X connect 5 0 8 0;
#X connect 6 0 26 0;
#X connect 7 0 13 0;
#X connect 8 0 7 0;
#X connect 10 0 9 0;
#X connect 11 0 27 0;
#X connect 11 1 7 1;
#X connect 13 0 11 0;
#X connect 17 0 7 0;
#X connect 24 0 25 0;
#X connect 25 0 11 0;
#X connect 26 0 24 0;
#X connect 27 0 28 0;
#X connect 28 0 2 0;
