<?xml version="1.0" standalone="no" ?>
<!DOCTYPE jmax-doc SYSTEM 'jmax.dtd'>
<jmax-doc>
<!-- $Id$ -->
<!--
	GridFlow Internals Manual
	Copyright (c) 2001 by Mathieu Bouchard and Alexandre Castonguay

	This whole file is pure crap. sorry.
-->
<section name="configuration macros">
	a toggle macro is one that is ON when defined (to anything) and
	OFF when not defined.

	<macro type="toggle" name="HAVE_PROFILING HAVE_TSC_PROFILING"> enable
	profiling (statistics about speed); this slows down most everything by an
	appreciable percentage (but normally much less than twofold); this
	requires i586.</macro>

	<macro name="FORMAT_LIST"> is in "config.h", generated by the "configure"
	script. Don't touch this.</macro>

	<macro name="GF_VERSION"> is a string containing version number.</macro>

	<macro name="GF_COMPILE_TIME"> contains the current date and time at
	the moment of the compilation.</macro>

	<macro type="toggle" name="HAVE_SPEED">
	 implies <k>NO_ASSERT</k> and <k>NO_DEADBEEF</k>.
	 </macro>

	<macro type="toggle" name="NO_ASSERT">
	 disables assert()'s bug detection.
	 </macro>

	<macro type="toggle" name="NO_DEADBEEF">
	 disables NEW()'s and DELETE()'s bug detection features.
	 </macro>

	<macro type="toggle" name="HAVE_X11_SHARED_MEMORY"/>
	<macro type="toggle" name="HAVE_PENTIUM"/>
	<macro type="toggle" name="HAVE_PENTIUM"/>
</section>

<section name="lang.h">
	<macro name="$"/>
	<macro name="NEW NEW2 NEW3 FREE REALLOC"/>
	qalloc2 qalloc qfree2 qfree qrealloc qdump
	uint8 uint16 uint32 uint64
	int8 int16 int32 int64
	float32 float64
	bool
	Object Class
	List Dict
</section>

<section name="bridge">
</section>

<section name="general-purpose macros">
	<macro name="assert assert_range"/>
	<macro name="COUNT ARRAY"/>
	<macro name="COERCE_INT_INTO_RANGE"/>
	<macro name="ENTER ENTER_P LEAVE LEAVE_P"/>
	<macro name="ATOMLIST"/>
	<macro name="METHOD_ARGS"/>
	<macro name="RAISE RAISE2"/>
	<macro name="DECL DECL2"/>
	<macro name="METHOD METHOD_PTR"/>
	<macro name="GRCLASS"/>
	<macro name="OBJ"/>
	<macro name="GET PUT"/>
	<macro name="SYM"/>
</section>

<section name="limits macros">
	<macro name="MAX_NUMBERS"/>
	<macro name="MAX_INDICES"/>
	<macro name="MAX_DIMENSIONS"/>
	<macro name="MAX_INLETS"/>
	<macro name="MAX_OUTLETS"/>
</section>

<section name="other macros">
	<macro name="GRID_BEGIN GRID_BEGIN_"/>
	<macro name="GRID_FLOW GRID_FLOW_"/>
	<macro name="GRID_FLOW2 GRID_FLOW2_"/>
	<macro name="GRID_END GRID_END_"/>
	<macro name="LIST GRINLET GRINLET2"/>
</section>

<section name="typedefs">
	<macro name="MethodDecl"/>
	<macro name="FTSMethod GridBegin GridFlow GridFlow2 GridEnd"/>

typedef enum NumberTypeIndex {
	DECL_TYPE(     uint8,  8),
	DECL_TYPE(      int8,  8),
	DECL_TYPE(    uint16, 16),
	DECL_TYPE(     int16, 16),
/*	DECL_TYPE(    uint32, 32), */
	DECL_TYPE(     int32, 32),
	
} NumberTypeIndex;

typedef struct NumberType {
	fts_symbol_t sym;
	const char *name;
	int size;
} NumberType;

</section>

<section name="support functions">
	mod ipow min max cmp rdtsc is_le

	void whine(char *fmt, ...);
	void whine_time(const char *s);
	int    gf_file_open(const char *name, int mode);
	FILE *gf_file_fopen(const char *name, int mode); 
	void define_many_methods(fts_class_t *class, int n, MethodDecl *methods);
</section>

<section name="support classes">
	<class name="Dim">
/*
  a const array that holds dimensions of a grid
  and can do some calculations on positions in that grid.
*/

	Dim *Dim_new(int n, int *v);
	Dim *Dim_dup(Dim *$);
	int Dim_count(Dim *$);
	int Dim_get(Dim *$, int i);
	int Dim_prod(Dim *$);
	int Dim_prod_start(Dim *$, int start);

	char *Dim_to_s(Dim *$);
	int Dim_equal_verbose(Dim *$, Dim *other);
	int Dim_equal_verbose_hwc(Dim *$, Dim *other);
	int Dim_dex_add(Dim *$, int n, int *dex);
	int Dim_calc_dex(Dim *$, int *v);
	</class>

	<class name="BitPacking">

	int high_bit(uint32 n);
	int low_bit(uint32 n);
	BitPacking *BitPacking_new(int bytes, uint32 r, uint32 g, uint32 b);
	void    BitPacking_whine(BitPacking *$);
	uint8  *BitPacking_pack(BitPacking *$, int n, const Number *data, uint8 *target);
	Number *BitPacking_unpack(BitPacking *$, int n, const uint8 *in, Number *out);
	int     BitPacking_bytes(BitPacking *$);

	</class>

	<class name="NumberType">
		unused
	</class>

	<class name="Operator1">
typedef struct Operator1 {
	fts_symbol_t sym;
	const char *name;
	Number (*op)(Number);
	void   (*op_array)(int,Number*);
} Operator1;

	extern Operator1 op1_table[];
	extern Dict *op1_dict;
	</class>

	<class name="Operator2">
typedef struct Operator2 {
	fts_symbol_t sym;
	const char *name;
	Number (*op)(Number,Number);
	void   (*op_array)(int,Number *,Number);
	void   (*op_array2)(int,Number *, const Number *);
	Number (*op_fold)(Number,int,const Number *);
} Operator2;

	extern Operator2 op2_table[];
	extern Dict *op2_dict;
	</class>

</section>

<section name="main classes">
	<class name="GridInlet"/>
	<class name="GridOutlet"/>
	<class name="GridObject"/>
	GridHandler
	GridClass
	<enum name="FormatFlags"/>
	Format_frame_m
	Format_frames_m
	Format_option_m
	Format_close_m
	<class name="FormatClass"/>
	<class name="Format"/>
	Format_FIELDS
	FORMAT_LIST
</section>

</jmax-doc>
