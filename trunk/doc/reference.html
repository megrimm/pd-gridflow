<html>
<head>
<!-- $Id$ -->
<title>GridFlow 0.6.4 - reference</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="jmax.css" type="text/css">
</head>
<body
  bgcolor="#FFFFFF"
  leftmargin="0"
  topmargin="0"
  marginwidth="0"
  marginheight="0">
<table
  width="100%"
  bgcolor="white"
  border="0"
  cellspacing="2">
<tr> 
<td colspan="4" bgcolor="#082069">
<img src="images/titre_gridflow.png" width="253" height="23"></td>
</tr>
<tr> 
<td>&nbsp;</td>
</tr>
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4" height="16"> 
    <h4>GridFlow 0.6.4 - reference index</h4>
</td></tr>
<tr> 
  <td width="5%" rowspan="2">&nbsp;</td>
  <td width="25%" height="23">&nbsp;</td>
  <td width="66%" height="23">&nbsp;</td>
  <td width="5%"  height="23">&nbsp;</td>
</tr>
<tr><td colspan="2"><h4><a href="#Objects_for_Input/Output">Objects for Input/Output</a></h4><ul>
<li><a href="#@in"><img src="images/@in.png" alt="[@in]" border="0"></a></li>
<li><a href="#@out"><img src="images/@out.png" alt="[@out]" border="0"></a></li>
<li><a href="#@import"><img src="images/@import.png" alt="[@import {240 320 3}]" border="0"></a></li>
<li><a href="#@export"><img src="images/@export.png" alt="[@export]" border="0"></a></li>
<li><a href="#@export_list"><img src="images/@export_list.png" alt="[@export_list]" border="0"></a></li>
<li><a href="#@two"><img src="images/@two.png" alt="[@two]" border="0"></a></li>
<li><a href="#@three"><img src="images/@three.png" alt="[@three]" border="0"></a></li>
<li><a href="#@four"><img src="images/@four.png" alt="[@four]" border="0"></a></li>
</ul>
<h4><a href="#Objects_for_Generating">Objects for Generating</a></h4><ul>
<li><a href="#@for"><img src="images/@for.png" alt="[@for 0 320 1]" border="0"></a></li>
</ul>
<h4><a href="#Objects_for_Computing">Objects for Computing</a></h4><ul>
<li><a href="#@"><img src="images/op/add.jpg" alt="[@ +]" border="0"></a></li>
<li><a href="#@!"><img src="images/@!.png" alt="[@!]" border="0"></a></li>
<li><a href="#@fold"><img src="images/@fold.png" alt="[@fold +]" border="0"></a></li>
<li><a href="#@scan">@scan</a></li>
<li><a href="#@outer"><img src="images/@outer.png" alt="[@outer +]" border="0"></a></li>
<li><a href="#@inner"><img src="images/@inner.png" alt="[@inner * + 0]" border="0"></a></li>
<li><a href="#@inner2"><img src="images/@inner2.png" alt="[@inner2 * + 0]" border="0"></a></li>
</ul>
<h4><a href="#Objects_for_Coordinate_Transforms">Objects for Coordinate Transforms</a></h4><ul>
<li><a href="#@redim"><img src="images/@redim.png" alt="[@redim {2}]" border="0"></a></li>
<li><a href="#@store"><img src="images/@store.png" alt="[@store]" border="0"></a></li>
<li><a href="#@identity_transform"><img src="images/@identity_transform.png" alt="[@identity_transform]" border="0"></a></li>
<li><a href="#@scale_to"><img src="images/@scale_to.png" alt="[@scale_to]" border="0"></a></li>
<li><a href="#@scale_by"><img src="images/@scale_by.png" alt="[@scale_by]" border="0"></a></li>
<li><a href="#@scale_down_by">@scale_down_by</a></li>
<li><a href="#@spread"><img src="images/@spread.png" alt="[@spread]" border="0"></a></li>
</ul>
<h4><a href="#Objects_for_Reporting">Objects for Reporting</a></h4><ul>
<li><a href="#@dim"><img src="images/@dim.png" alt="[@dim]" border="0"></a></li>
<li><a href="#@print">@print</a></li>
<li><a href="#rubyprint">rubyprint</a></li>
<li><a href="#printargs">printargs</a></li>
</ul>
<h4><a href="#Objects_for_Picture_Processing">Objects for Picture Processing</a></h4><ul>
<li><a href="#@convolve"><img src="images/@convolve.png" alt="[@convolve * + 0]" border="0"></a></li>
<li><a href="#@contrast"><img src="images/@contrast.png" alt="[@contrast]" border="0"></a></li>
<li><a href="#@posterize"><img src="images/@posterize.png" alt="[@posterize]" border="0"></a></li>
<li><a href="#@checkers">@checkers</a></li>
<li><a href="#@layer">@layer</a></li>
</ul>
<h4><a href="#Special_Objects">Special Objects</a></h4><ul>
<li><a href="#rtmetro">rtmetro</a></li>
<li><a href="#pingpong">pingpong</a></li>
<li><a href="#@global"><img src="images/@global.png" alt="[@global]" border="0"></a></li>
</ul>
<h4><a href="#External_Picture_Formats">External Picture Formats</a></h4><ul>
<li><a href="#format ppm @in/@out"><img src="images/format_ppm.png" alt="[open ppm file filename.ppm]" border="0"></a></li>
<li><a href="#format targa @in"><img src="images/format_targa.png" alt="[open targa file filename.tga]" border="0"></a></li>
<li><a href="#format jpeg @in">format jpeg @in</a></li>
<li><a href="#format mpeg @in"><img src="images/format_mpeg.png" alt="[open mpeg file filename.mpeg]" border="0"></a></li>
<li><a href="#format grid @in/@out"><img src="images/format_grid.png" alt="[open grid file filename.grid]" border="0"></a></li>
<li><a href="#format videodev @in"><img src="images/format_videodev.png" alt="[open videodev /dev/video0]" border="0"></a></li>
<li><a href="#format sdl @out">format sdl @out</a></li>
<li><a href="#format x11 @in/@out"><img src="images/format_x11.png" alt="[open x11 here]" border="0"></a></li>
</ul>
<h4><a href="#Objects_for_Scripting">Objects for Scripting</a></h4><ul>
<li><a href="#ruby class FObject extending Data">ruby class FObject extending Data</a></li>
<li><a href="#ruby class GridObject extending FObject">ruby class GridObject extending FObject</a></li>
<li><a href="#ruby class BitPacking">ruby class BitPacking</a></li>
</ul>
<h4><a href="#Objects_for_Internals">Objects for Internals</a></h4><ul>
<li><a href="#C++ class GridInlet">C++ class GridInlet</a></li>
<li><a href="#C++ class GridOutlet">C++ class GridOutlet</a></li>
<li><a href="#C++ class Dim">C++ class Dim</a></li>
<li><a href="#C++ class Grid">C++ class Grid</a></li>
<li><a href="#C++ class Operator1">C++ class Operator1</a></li>
<li><a href="#C++ class Operator2">C++ class Operator2</a></li>
<li><a href="#C++ class GridClass">C++ class GridClass</a></li>
<li><a href="#C++ class GFBridge">C++ class GFBridge</a></li>
</ul>
<br><br>
</td></tr> 
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><a name="Objects_for_Input/Output"></a><h4>Objects for Input/Output</h4></td></tr> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@in">@in</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@in.png" alt="[@in]" border="0"><br clear="left"><br><br><a href="images/help_@inout.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <br><b>method</b> init <b>(</b>format<b>, </b>format_specific_part...<b>)</b>    
			If no arguments given, creates an input object for an unspecified 
			format. You then need to use the <kbd>open</kbd> command to link 
			a format handler to it. 
			If arguments given, the <kbd>open</kbd> command is immediately called 
			with those arguments. 
			Remember that most formats produce Dim[rows,columns,3] grids with 
			0-255 values. (Most.) <br>
  <br><b>inlet 0</b> <b>method</b> open <b>(</b>format<b>, </b>format_specific_part...<b>)</b>    
				This is the command that gives a particular resource 
				to a @out object. This is done through a "format" 
				(there is a list of formats in this manual). The other 
				arguments depend on the chosen format. The format may 
				be a file format or a protocol or a hardware device, etc. <br>
 <br><b>inlet 0</b> <b>method</b> close <b>(</b><b>)</b>  
				close may be necessary if you operate on "/dev/video", 
				which can only be read by one at a time. otherwise it's 
				usually not necessary. <br>
 <br><b>inlet 0</b> <b>method</b> int <b>(</b>frame_number<b>)</b>   
				selects one picture from a multi-picture format 
				and then does the same as a bang. <br>
 <br><b>inlet 0</b> <b>method</b> bang <b>(</b><b>)</b>  
				sends a grid through the outlet. the grid may be the 
				result of reading from a file, acquiring from a device, 
				capturing from the screen etc. 
				this is format-specific. most formats 
				produce <b>dim(</b>rows columns {red green blue}<b>)</b>. 
				In formats that read from a file, reading another picture 
				will continue if there are several pictures in the 
				same file, but if the end of file is reached instead, 
				it will rewind and send the first picture again. 
				see section "External Picture Formats". <br>
 <br><b>inlet 0</b> <b>method</b> option <b>(</b><i>symbol</i> selector<b>, </b>stuff...<b>)</b>    
				for format-specific options. 
				(usually in devices that masquerade as formats). 
				see section "External Picture Formats". <br>
 <br><b>inlet 0</b> <b>method</b> option rewind <b>(</b><b>)</b>  
				rewinds to beginning of file if applicable. <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@out">@out</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@out.png" alt="[@out]" border="0"><br clear="left"><br><br><a href="images/help_@inout.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <br><b>method</b> init <b>(</b>format<b>, </b>format_specific_part...<b>)</b>    
			If no arguments given, creates an output object for an unspecified 
			format. You then need to use the <kbd>open</kbd> command to link 
			a format handler to it. 
			If arguments given, the <kbd>open</kbd> command is immediately called 
			with those arguments. 
			Remember that most formats expect dim(rows,columns,3) grids with 
			0-255 values. (Most.) <br>
 <br><b>method</b> init <b>(</b><i>integer</i> rows<b>, </b><i>integer</i> columns<b>)</b>    
			This alternate way to create an @out automatically calls 
			"open x11 here" and "option out_size <i>rows columns</i>". <br>
  <br><b>inlet 0</b> <b>method</b> open <b>(</b>format<b>, </b>format_specific_part...<b>)</b>    
				This is the command that gives a particular resource 
				to a @out object. This is done through a "format" 
				(there is a list of formats in this manual). The other 
				arguments depend on the chosen format. The format may 
				be a file format or a protocol or a hardware device, etc. <br>
 <br><b>inlet 0</b> <b>grid</b>  
				this is format-specific. most formats 
				expect <b>dim(</b>rows columns {red green blue}<b>)</b>. 
				In formats that write to a file, sending a 2nd picture 
				overwrites the first. 
				see section "External Picture Formats". <br>
 <br><b>inlet 0</b> <b>method</b> close <b>(</b><b>)</b>  
				closes the file. usually not necessary. <br>
 <br><b>inlet 0</b> <b>method</b> option <b>(</b><i>symbol</i> selector<b>, </b>stuff...<b>)</b>    
				for format-specific options. 
				(usually in devices that masquerade as formats). 
				see section "External Picture Formats". <br>
 <br><b>inlet 0</b> <b>method</b> option timelog <b>(</b><i>0,1</i> status<b>)</b>   
				when status=1, current time (unix clock) and time since last 
				frame-end are printed in the console. when status=0, it is off. 
				default is 0. <br>
 <br><b>inlet 0</b> <b>method</b> option rewind <b>(</b><b>)</b>  
				rewinds to beginning of file if applicable. 
				will overwrite the previous data. <br>
   <br><b>outlet 0</b> <b>method</b> bang <b>(</b><b>)</b>  
				sent when a complete grid has been received. <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@import">@import</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@import.png" alt="[@import {240 320 3}]" border="0"><br clear="left"><br><br><a href="images/help_@importexport.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>This object allows you to import non-grid jMax data, such as 
		integers and lists of integers. This object also reframes/resyncs 
		integers and grids so that multiple grids may be joined together, or 
		single grids may be split.</p> <br><b>method</b> init <b>(</b><i>list(+integer)</i> dims<b>)</b>   
			a list specifying a grid shape that the numbers 
			will fit into. <br>
  <br><b>inlet 0</b> <b>method</b> int <b>(</b><b>)</b>  
				begins a new grid if there is no current grid. 
				puts that integer in the current grid. 
				ends the grid if it is full. 
				the constructed grid is not stored: it is streamed. 
				the stream is buffered, so the output is in packets 
				of about a thousand numbers. <br>
 <br><b>inlet 0</b> <b>method</b> reset <b>(</b><b>)</b>  
				aborts the current grid if there is one. <br>
 <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>dims...<b>)</b> 
				this is the equivalent of filtering this grid through 
				an @export object and sending the resulting integers 
				to this @import object, except that it's about 
				10 times faster. <br>
   <br><b>inlet 1</b> <b>grid</b> <b>dim(</b>rank<b>)</b> 
				this grid is a dimension list that replaces the one 
				specified in the constructor. <br>
   <br><b>outlet 0</b> <b>grid</b>  
				the grid produced from incoming integers and/or grids. <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@export">@export</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@export.png" alt="[@export]" border="0"><br clear="left"><br><br><a href="images/help_@importexport.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>this object is the opposite of @import.</p> <br><b>method</b> init <b>(</b><b>)</b>  
			this object is not configurable because there isn't 
			anything that could possibly be configured here. <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>dims...<b>)</b> 
				transforms this grid into a sequence of integer messages. <br>
   <br><b>outlet 0</b> <b>method</b> int <b>(</b><b>)</b>  
				elements of the incoming grid. <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@export_list">@export_list</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@export_list.png" alt="[@export_list]" border="0"><br clear="left"><br><br><a href="images/help_@importexport.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>this object is another opposite of @import, which puts 
		all of its values in a jMax list.</p> <br><b>method</b> init <b>(</b><b>)</b>  
			this object is not configurable because there isn't 
			anything that could possibly be configured here. <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>dims...<b>)</b> 
				transforms this grid into a single message containing 
				a list of integers. <br>
   <br><b>outlet 0</b> <b>method</b> list <b>(</b><b>)</b>  
				elements of the incoming grid. <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@two">@two</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@two.png" alt="[@two]" border="0"><br clear="left"><br><br><a href="images/help_@twothreefour.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p> holds two values, defaulting to (0,0). each time one is 
		changed (by sending an integer in that inlet), a Dim(2) grid 
		of those values is sent through the outlet.</p> <br><b>method</b> init <b>(</b><b>)</b> no arguments.<br>
 <br><b>inlet 0</b> <b>method</b> int <b>(</b><b>)</b> <br>
 <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b> <br>
 <br><b>outlet 0</b> <b>grid</b> <b>dim(</b>2<b>)</b><br>
 <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@three">@three</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@three.png" alt="[@three]" border="0"><br clear="left"><br><br><a href="images/help_@twothreefour.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p> holds three values, defaulting to (0,0,0). each time one is 
		changed (by sending an integer in that inlet), a Dim(3) grid 
		of those values is sent through the outlet.</p> <br><b>method</b> init <b>(</b><b>)</b> no arguments.<br>
 <br><b>inlet 0</b> <b>method</b> int <b>(</b><b>)</b> <br>
 <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b> <br>
 <br><b>inlet 2</b> <b>method</b> int <b>(</b><b>)</b> <br>
 <br><b>outlet 0</b> <b>grid</b> <b>dim(</b>3<b>)</b><br>
 <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@four">@four</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@four.png" alt="[@four]" border="0"><br clear="left"><br><br><a href="images/help_@twothreefour.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p> holds four values, defaulting to (0,0,0,0). each time one is 
		changed (by sending an integer in that inlet), a Dim(4) grid 
		of those values is sent through the outlet.</p> <br><b>method</b> init <b>(</b><b>)</b> no arguments.<br>
 <br><b>inlet 0</b> <b>method</b> int <b>(</b><b>)</b> <br>
 <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b> <br>
 <br><b>inlet 2</b> <b>method</b> int <b>(</b><b>)</b> <br>
 <br><b>inlet 3</b> <b>method</b> int <b>(</b><b>)</b> <br>
 <br><b>outlet 0</b> <b>grid</b> <b>dim(</b>4<b>)</b><br>
 <br></td> 
<tr><td>&nbsp;</td></tr>
 
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><a name="Objects_for_Generating"></a><h4>Objects for Generating</h4></td></tr> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@for">@for</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@for.png" alt="[@for 0 320 1]" border="0"><br clear="left"><br><br><a href="images/help_@for.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>when given scalar bounds, works like a regular [for] object plugged 
		to a [@import] tuned for a Dim(size) where size is the number of values 
		produced by a bang to that [for].</p> <p>when given vector bounds, will work like any number of [for] objects 
		producing all possible combinations of their values in the proper order. 
		This replaces the old [@identity_transform] object.</p> <br><b>method</b> init <b>(</b><i>integer</i> from<b>, </b><i>integer</i> to<b>, </b><i>integer</i> step<b>)</b>     <br>
 <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>index<b>)</b> 
			replaces the "from" value and produces output. <br>
 <br><b>inlet 1</b> <b>grid</b> <b>dim(</b>index<b>)</b> 
			replaces the "to" value. <br>
 <br><b>inlet 2</b> <b>grid</b> <b>dim(</b>index_steps<b>)</b> 
			replaces the "step" value. <br>
  <br><b>outlet 0</b> <b>grid</b> <b>dim(</b>size<b>)</b> 
				where size is floor((to-from+1)/step) 
				[for scalar bounds] <br>
 <br><b>outlet 0</b> <b>grid</b> <b>dim(</b>*size,dimension<b>)</b> 
				where *size is floor((to-from+1)/step) 
				[for vector bounds] <br>
  <br></td> 
<tr><td>&nbsp;</td></tr>
 
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><a name="Objects_for_Computing"></a><h4>Objects for Computing</h4></td></tr> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@">@</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/op/add.jpg" alt="[@ +]" border="0"><br clear="left"><br><br><a href="images/help_@.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>This object outputs a grid by computing "in parallel" a same 
		operation on each left-hand element with its corresponding right-hand 
		element. This is a massively parallel version of jMax's builtin 
		arithmetic operators. In case you wonder, it's only parallel in the 
		sense that all those computations are independent; there's no 
		guarantee about how many of them will actually be computed at once. </p> <br><b>method</b> init <b>(</b><i>symbol</i> operator<b>, </b><i>integer|grid</i> value<b>)</b>    
			the operator is one picked in the table of the 30 two-input 
			operators. the value (optional, zero by default) becomes 
			the initial value of the right inlet. it may be a grid. <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>dims...<b>)</b> 
				on each element of this grid, perform the operation 
				together with the corresponding element of inlet 1. 
				in the table of operators (at the top of this document) 
				elements of inlet 0 are called "A" and elements of inlet 1 
				are called "B". the resulting grid is the same size as the 
				one in inlet 0. <br>
   <br><b>inlet 1</b> <b>grid</b> <b>dim(</b>dims...<b>)</b> 
				any grid, preferably shaped like the one that will be put 
				in the left inlet, or like a subpart of it (the contents 
				will be redim'ed on the fly to fit the grid of inlet-0, 
				but the stored grid will not be modified itself) <br>
 <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b>  
				stores a single int in the right inlet; the same int will 
				be applied in all computations; this is like sending a 
				Dim(1) or Dim() grid with that number in it. <br>
   <br><b>outlet 0</b> <b>grid</b>  <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@!">@!</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@!.png" alt="[@!]" border="0"><br clear="left"><br><br><a href="images/help_@!.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>This object computes a grid by computing "in parallel" a same 
		operation on each element of the grid. </p> <br><b>method</b> init <b>(</b><i>symbol</i> operator<b>)</b>   
			the operator is one picked in the table of the 3 one-input 
			operators. <br>
  <br><b>inlet 0</b> <b>grid</b>  <br>
   <br><b>outlet 0</b> <b>grid</b>  <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@fold">@fold</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@fold.png" alt="[@fold +]" border="0"><br clear="left"><br><br><a href="images/help_@foldinnerouter.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p><ul> <li><b>1</b> : [@fold +] computes totals</li> <li><b>2</b> : [@fold inv+] is an alternated sum (+/-)</li> <li><b>3</b> : [@fold * 1] can compute the size of a grid using its dimension list</li> <li><b>4</b> : [@fold & 1] can mean "for all"</li> <li><b>5</b> : [@fold | 0] can mean "there exists (at least one)"</li> <li><b>6</b> : [@fold ^ 0] can mean "there exists an odd number of..."</li> <li><b>7</b> : [@fold ^ 1] can mean "there exists an even number of...".</li> </ul></p> <br><b>method</b> init <b>(</b><i>symbol</i> operator<b>, </b><i>integer</i> base<b>, </b><i>grid</i> right_hand<b>)</b>     
			the base value is optional and defaults to 0. 
			the operator is one from the table of two-input operators. <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>dims..., last<b>)</b> 
				replaces every Dim(last) subgrid by the result of a cascade on that subgrid. 
				Doing that 
				with base value 0 and operation + on grid "2 3 5 7" will compute 
				((((0+2)+3)+5)+7) find the total "17". 
				produces a Dim(dims) grid. <br>
   <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b>  
				changes the base value to use. <br>
    <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@scan">@scan</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 <p>[@scan +] computes subtotals.</p> <br><b>method</b> init <b>(</b><i>symbol</i> operator<b>, </b><i>integer</i> base<b>)</b>    
			the base value is optional and defaults to 0. 
			the operator is one from the table of two-input operators. <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>dims..., last<b>)</b> 
				replaces every Dim(last) subgrid by all the result of a cascade on that 
				subgrid. Doing that with base value 0 and operation + on grid "2 3 5 7" will 
				compute 0+2=2, 2+3=5, 5+5=10, 10+7=17, and gives the subtotals "2 5 10 17". 
				produces a Dim(dims,last) grid. <br>
   <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b>  
				changes the base value to use. <br>
    <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@outer">@outer</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@outer.png" alt="[@outer +]" border="0"><br clear="left"><br><br><a href="images/help_@foldinnerouter.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <br><b>method</b> init <b>(</b><i>symbol</i> operator<b>, </b><i>grid</i> value<b>)</b>    
			the operator must be picked from the table of two-input operators. 
			the grid is optional and corresponds to inlet 1. <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>anyA...<b>)</b><br>
 
			produces a grid of size Dim(anyA..., anyB...), where numbers 
			are the results of the operation on every element of A and 
			every element of B. the resulting array can be very big. Don't 
			try this on two pictures (the result will have 6 dimensions)   <br><b>inlet 1</b> <b>grid</b> <b>dim(</b>anyB...<b>)</b><br>
 
			stores the specified grid, to be used when inlet 0 is activated.    <p>When given a grid of Dim(3) and a grid of Dim(5) [@outer] will 
		produce  a grid of Dim(3,5) with the selected two-input operation 
		applied on each  of the possible pairs combinations between numbers 
		from the left grid  and the ones from the right. for example : 
		(10,20,30) [@outer +] (1,2,3)  will give : 
		((11,12,13),(21,22,23),(31,32,33)) </p> <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@inner">@inner</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@inner.png" alt="[@inner * + 0]" border="0"><br clear="left"><br><br><a href="images/help_@foldinnerouter.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>think of this one as a special combination of [@outer], [@] 
		and [@fold]. this is one of the most complex operations. It is very 
		useful for performing linear transforms like rotations, scalings, 
		tilts, and color remappings. A linear transform is done by something called matrix 
		multiplication, which happens to be [@inner * + 0]. </p> <p>This object has been renamed from @inner to @inner2 because a 
		different @inner object will be added in the future.</p> <br><b>method</b> init <b>(</b><i>symbol</i> op_para<b>, </b><i>symbol</i> op_fold<b>, </b><i>integer</i> base<b>, </b><i>grid</i> right_hand<b>)</b>      
			op_para and op_fold are two operators picked from the table 
			of two-input operators. 
			the base value has to be specified (has no default value yet). <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>anyA..., lastA<b>)</b> 
				Splits the Dim(anyA...,lastA) left-hand grid into Dim(anyA...) pieces 
				of Dim(lastA) size. 
				Splits the Dim(firstB,anyB...) right-hand grid into Dim(anyB...) pieces 
				of Dim(firstB) size. 
				On every piece pair, does [@] using the specified 
				op_para operation, followed by a [@fold] using 
				the specified op_fold operator and base value. 
				creates a Dim(anyA...,anyB...) grid by assembling all 
				the results together. 
				(note: lastA must be equal to firstB.) <br>
   <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b>  
				changes the base value to that. <br>
   <br><b>inlet 2</b> <b>grid</b> <b>dim(</b>anyB..., lastB<b>)</b> 
				changes the right-hand side grid to that. <br>
    <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@inner2">@inner2</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@inner2.png" alt="[@inner2 * + 0]" border="0"><br clear="left"><br><br><a href="images/help_@foldinnerouter.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>a variant on @inner.</p> <p>This object used to be called @inner.</p> <br><b>method</b> init <b>(</b><i>symbol</i> op_para<b>, </b><i>symbol</i> op_fold<b>, </b><i>integer</i> base<b>, </b><i>grid</i> right_hand<b>)</b>      
			op_para and op_fold are two operators picked from the table 
			of two-input operators. 
			the base value has to be specified (has no default value yet). <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>anyA..., lastA<b>)</b> 
				Splits the Dim(anyA...,lastA) left-hand grid into Dim(anyA...) pieces 
				of Dim(lastA) size. 
				Splits the Dim(anyA...,lastB) right-hand grid into Dim(anyB...) pieces 
				of Dim(lastB) size. 
				On every piece pair, does [@] using the specified 
				op_para operation, followed by a [@fold] using 
				the specified op_fold operator and base value. 
				creates a Dim(anyA...,anyB...) grid by assembling all 
				the results together. 
				(note: lastA must be equal to lastB.) <br>
   <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b>  
				changes the base value to that. <br>
   <br><b>inlet 2</b> <b>grid</b> <b>dim(</b>anyB..., lastB<b>)</b> 
				changes the right-hand side grid to that. <br>
    <br></td> 
<tr><td>&nbsp;</td></tr>
 
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><a name="Objects_for_Coordinate_Transforms"></a><h4>Objects for Coordinate Transforms</h4></td></tr> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@redim">@redim</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@redim.png" alt="[@redim {2}]" border="0"><br clear="left"><br><br><a href="images/help_@redim.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <br><b>method</b> init <b>(</b><i>list(+integer)</i> dims<b>)</b>   
			a list specifying a grid shape that the numbers 
			will fit into. 
			(same as with @import) <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>dims...<b>)</b> 
			the elements of this grid are serialized. if the resulting grid 
			must be larger, the sequence is repeated as much as necessary. 
			if the resulting grid must be smaller, the sequence is truncated. 
			then the elements are deserialized to form the resulting grid. <br>
   <br><b>inlet 1</b> <b>grid</b> <b>dim(</b>rank<b>)</b> 
				this grid is a dimension list that replaces the one 
				specified in the constructor. 
				(same as with @import) <br>
   <br><b>outlet 0</b> <b>grid</b>  
				redimensioned grid potentially containing repeating data. <br>
  <p>example: with a 240 320 RGB image, @redim 120 640 3 will visually 
		separate the even lines (left) from the odd lines (right). contrary 
		to this, @redim 640 120 3 will split every line and put its left half 
		on a even line and the right half on the following odd line. @redim 
		480 320 3 will repeat the input image twice in the output image. 
		@redim 240 50 3 will only keep the 50 top lines.</p> <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@store">@store</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@store.png" alt="[@store]" border="0"><br clear="left"><br><br><a href="images/help_@store.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>A @store object can store exactly one grid, using the right 
		inlet. You fetch it back, or selected subparts thereof, using the left 
		inlet.</p> <br><b>method</b> init <b>(</b><i>int32 | uint8</i> number_type<b>)</b>   
			The number type argument is optional and by default is int32, 
			which allows the usual range of plus/minus two billions. With 
			uint8, values are wrapped into the 0..255 interval, and stored 
			in four times less memory. <br>
  <br><b>inlet 0</b> <b>method</b> bang <b>(</b><b>)</b>  
				the stored grid is fully sent to the outlet. <br>
 <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>dims..., indices<b>)</b> 
				in this grid, the last dimension refers to subparts of 
				the stored grid. sending a Dim(200,200,2) on a @store 
				that holds a Dim(240,320,3) will cause the @store to handle 
				the incoming grid as a Dim(200,200) of Dim(2)'s, where each 
				Dim(2) represents a position in a Dim(240,320) of Dim(3)'s. 
				therefore the resulting grid will be a Dim(200,200) of 
				Dim(3) which is a Dim(200,200,3). in practice this example 
				would be used for generating a 200*200 RGB picture from a 
				200*200 XY map and a 240*320 RGB picture. this object can 
				be logically used in the same way for many purposes 
				including color palettes, tables of probabilities, tables 
				of statistics, whole animations, etc. <br>
   <br><b>inlet 1</b> <b>grid</b> <b>dim(</b>dims...<b>)</b> 
				the received grid is stored. if the storage type is uint8, 
				the input is filtered to fit 0..255. <br>
   
			grids as stored, as indexed, or as assembled from multiple 
			indexings.  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@identity_transform">@identity_transform</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@identity_transform.png" alt="[@identity_transform]" border="0"><br clear="left"><br><br><a href="images/help_@identity_transform.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p> 
			OBSOLETE AND REMOVED. USE @for INSTEAD. </p> <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@scale_to">@scale_to</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@scale_to.png" alt="[@scale_to]" border="0"><br clear="left"><br><br><a href="images/help_@scale_to.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <br><b>method</b> init <b>(</b><b>)</b>  
			no arguments. <br>
  <br><b>inlet 0</b> <b>grid</b> a 3-channel picture to be scaled.<br>
   <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b> a height.<br>
   <br><b>inlet 2</b> <b>method</b> int <b>(</b><b>)</b> a width.<br>
   <br><b>outlet 0</b> <b>grid</b> a scaled 3-channel picture.<br>
  <p>@scale_to is normally fed the same inlet 1,2 values as 
		@identity_transform, and chained from @identity_transform and to 
		@store. This will scale an image of any size to the size specified 
		in inlets 1,2. If it doesn't correspond the values of 
		@identity_transform, part of the image will be trimmed and/or 
		duplicated.</p> <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@scale_by">@scale_by</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@scale_by.png" alt="[@scale_by]" border="0"><br clear="left"><br><br><a href="images/help_@scale_by.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <br><b>method</b> init <b>(</b><i>grid dim() or dim(2)</i> factor<b>)</b>   
			factor is optional (default is 2). 
			if it's a single value, then that factor is to be used 
			for both rows and columns. <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>y x {r g b}<b>)</b> 
			identical to @scale_to with arguments that are exactly 
			twice those of the incoming grid. It is several times faster. <br>
   <br><b>outlet 0</b> <b>grid</b> <b>dim(</b>(factor*y) (factor*x) {r g b}<b>)</b><br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@scale_down_by">@scale_down_by</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 <br><b>method</b> init <b>(</b><i>+integer</i> factor<b>, </b><i>optional symbol(smoothly)</i> how<b>)</b>    
			factor is optional (default is 2). 
			if it's a single value, then that factor is to be used 
			for both rows and columns. <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>y x {r g b}<b>)</b> 
			Scales down picture by specified amount. <br>
   <br><b>outlet 0</b> <b>grid</b> <b>dim(</b>(factor/y) (factor/x) {r g b}<b>)</b><br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@spread">@spread</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@spread.png" alt="[@spread]" border="0"><br clear="left"><br><br><a href="images/help_@spread.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>typically you plug a @identity_transform into this object, 
		and you plug this object into the left side of a @store. it will 
		scatter pixels around, giving an "unpolished glass" effect.</p> <br><b>method</b> init <b>(</b><b>)</b>  
			no arguments. <br>
  <br><b>inlet 0</b> <b>grid</b> a coordinate map.<br>
   <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b> a spread factor.<br>
   <br><b>outlet 0</b> <b>grid</b> a coordinate map.<br>
  <p>@spread scatters the pixels in an image. Not all original pixels 
		will  appear, and some may get duplicated (triplicated, etc) 
		randomly. Some  wrap-around effect will occur close to the edges. </p> <p> Sending an integer to inlet 1 sets the amount of spreading in 
		maximum  number of pixels + 1. even values translate the whole image 
		by half  a pixel due to rounding.</p> <br></td> 
<tr><td>&nbsp;</td></tr>
 
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><a name="Objects_for_Reporting"></a><h4>Objects for Reporting</h4></td></tr> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@dim">@dim</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@dim.png" alt="[@dim]" border="0"><br clear="left"><br><br><a href="images/help_@dim.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>Returns list of dimensions as a grid. Given a grid sized like Dim(240,320,4), 
		@dim will return a grid like Dim(3), whose values are 240, 320, 4. </p> <br><b>method</b> init <b>(</b><b>)</b>  
			no arguments. <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>dims...<b>)</b> 
				ignores any data contained within. 
				sends a grid dim(length of dims) containing dims. <br>
   <br><b>outlet 0</b> <b>grid</b> <b>dim(</b>rank<b>)</b> 
				the list of dimensions of the incoming grid. <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@print">@print</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 <br><b>method</b> init <b>(</b><b>)</b> <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>dims...<b>)</b> 
			prints the dimensions of the grid. 
			prints all the grid data if there are 2 dimensions or less. <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="rubyprint">rubyprint</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 <br><b>method</b> init <b>(</b><b>)</b> <br>
  <br><b>inlet 0</b> <b>method</b> <any> <b>(</b><b>)</b>  
			prints the message to the console. <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="printargs">printargs</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 <br><b>method</b> init <b>(</b>any...<b>)</b>   
			prints everything. <br>
 <br></td> 
<tr><td>&nbsp;</td></tr>
 
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><a name="Objects_for_Picture_Processing"></a><h4>Objects for Picture Processing</h4></td></tr> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@convolve">@convolve</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@convolve.png" alt="[@convolve * + 0]" border="0"><br clear="left"><br><br><a href="images/help_@convolve.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>this is the object for blurring, sharpening, finding edges, 
		embossing, and many other uses.</p> <br><b>method</b> init <b>(</b><i>symbol</i> op_para<b>, </b><i>symbol</i> op_fold<b>, </b><i>integer</i> base<b>, </b><i>grid</i> right_hand<b>)</b>      <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>rows columns rest...<b>)</b> 
				splits the incoming grid into dim(rest...) parts. 
				for each of those parts at (y,x), a rectangle of such 
				parts, centered around (y,x), is combined with the 
				convolution grid like a [@] of operation op_para. Then 
				each such result is folded like [@fold] of operation 
				op_fold and specified base. the results are assembled 
				into a grid that is sent to the outlet. near the borders of 
				the grid, coordinates wrap around. this means the whole grid 
				has to be received before production of the next grid 
				starts. <br>
   <br><b>inlet 1</b> <b>grid</b> <b>dim(</b>rows2 columns2<b>)</b> 
				this is the convolution grid and it gets stored in 
				the object. rows2 and columns2 must be odd numbers. <br>
   <br><b>outlet 0</b> <b>grid</b> <b>dim(</b>rows columns rest...<b>)</b> <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@contrast">@contrast</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@contrast.png" alt="[@contrast]" border="0"><br clear="left"><br><br><a href="images/help_@contrast.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <br><b>method</b> init <b>(</b><b>)</b>  
			no arguments. <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>rows columns channels<b>)</b> 
			produces a grid like the incoming grid but with 
			different constrast. <br>
 <p>@contrast adjusts the intensity in an image. 
			resulting values outside 0-255 are automatically clipped.</p>   <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b>  
			this is the secondary contrast. it makes the incoming black 
			correspond to a certain fraction between output black and the 
			master contrast value. no effect is 256. default value is 256. <br>
   <br><b>inlet 2</b> <b>method</b> int <b>(</b><b>)</b>  
			this is the master contrast. it makes the incoming white 
			correspond to a certain fraction between output black and output 
			white. no effect is 256. default value is 256. <br>
   <br><b>outlet </b> <b>grid</b> <b>dim(</b>rows columns channels<b>)</b> <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@posterize">@posterize</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@posterize.png" alt="[@posterize]" border="0"><br clear="left"><br><br><a href="images/help_@posterize.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p>@posterize reduces the number of possible intensities in an image; 
		it rounds the color values.The effect is mostly apparent with a low 
		number of levels.</p> <br><b>method</b> init <b>(</b><b>)</b>  
			no arguments. <br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>rows columns channels<b>)</b> 
				produces a posterized picture from the input picture. <br>
   <br><b>inlet 1</b> <b>method</b> int <b>(</b><b>)</b>  
				this is the number of possible levels per channel. the 
				levels are equally spaced, with the lowest at 0 and the 
				highest at 255. the minimum number of levels is 2, and the 
				default value is 2. <br>
    <p>example: simulate the 216-color "web" palette using 6 levels. 
		simulate a 15-bit display using 32 levels.</p> <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@checkers">@checkers</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>y x {y x}<b>)</b> 
				result from a [@for {0 0} {height width} {1 1}] <br>
   <br><b>outlet 0</b> <b>grid</b> <b>dim(</b>y x {r g b}<b>)</b> 
				checkered pattern of 50%/75% greys 
				in 8x8 squares <br>
  <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@layer">@layer</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
  <br><b>inlet 0</b> <b>grid</b> <b>dim(</b>y x {r g b a}<b>)</b> 
				a picture that has an opacity channel. 
				will be used as foreground. <br>
   <br><b>inlet 1</b> <b>grid</b> <b>dim(</b>y x {r g b}<b>)</b> 
				a picture that has NO opacity channel. 
				will be used as background. <br>
   <br><b>outlet 0</b> <b>grid</b> <b>dim(</b>y x {r g b}<b>)</b> 
				a picture that has NO opacity channel. 
				the opacity channel of the foreground is used as 
				a weighting of how much of either picture is seen 
				in the result. <br>
  <br></td> 
<tr><td>&nbsp;</td></tr>
 
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><a name="Special_Objects"></a><h4>Special Objects</h4></td></tr> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="rtmetro">rtmetro</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		this is like jMax's builtin metro object. metro ensures that 
		there is at least a given delay between bangs. rtmetro ensures 
		that on average there is a given delay between bangs: it will 
		compensate too long delays by shorter delays. of course this won't 
		work if the system cannot keep up with the amount of work. <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="pingpong">pingpong</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		send a value in inlet 1 first. if successive increasing values are 
		sent in inlet 0, then output values will be successive increasing 
		until they reach the right inlet value and then decrease to zero. 
		the formula is stateless and so same inputs give always same output. <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="@global">@global</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/@global.png" alt="[@global]" border="0"><br clear="left"><br><br><a href="images/help_@global.png"><img src="images/see_screenshot.png" border="0"></a><br clear="left"><br></td><td><br>
   <p> 
		objects of this class do nothing by themselves and are just 
		an access point to features that don't belong to any object in 
		particular. </p> <br><b>method</b> profiler_reset <b>(</b><b>)</b>  
			resets all the time counters. <br>
 <br><b>method</b> profiler_dump <b>(</b><b>)</b>  
			displays the time counters in decreasing order, with 
			the names of the classes those objects are in. this is 
			an experimental feature. like most statistics, 
			it could be vaguely relied upon if 
			only you knew to which extent it is unreliable. more on this 
			in a future section called "profiling". <br>
 <br></td> 
<tr><td>&nbsp;</td></tr>
 
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><a name="External_Picture_Formats"></a><h4>External Picture Formats</h4></td></tr> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="format ppm @in/@out">format ppm @in/@out</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/format_ppm.png" alt="[open ppm file filename.ppm]" border="0"><br clear="left"><br><br><br clear="left"><br></td><td><br>
  <p>Subformat P6 only. 
		Max-number can only be 255 (24-bit RGB). </p> <br><b>method</b> open ppm file <b>(</b><i>symbol</i> filename<b>)</b>   
			opens the specified file, taken from the current 
			directory or one of the jMax-specified data directories. <br>
 <br><b>method</b> open ppm gzfile <b>(</b><i>symbol</i> filename<b>)</b>   
			same but for .ppm.gz files <br>
 <br><b>grid</b> <b>dim(</b>rows columns 3<b>)</b> 
			values 0-255 <br>
 <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="format targa @in">format targa @in</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/format_targa.png" alt="[open targa file filename.tga]" border="0"><br clear="left"><br><br><br clear="left"><br></td><td><br>
  <p>Support for RGB-24 (3 channels) and RGBA-32 (4 channels)</p> <br><b>method</b> open ppm file <b>(</b><i>symbol</i> filename<b>)</b>   
			opens the specified file, taken from the current 
			directory or one of the jMax-specified data directories. <br>
 <br><b>method</b> open ppm gzfile <b>(</b><i>symbol</i> filename<b>)</b>   
			same but for .tga.gz files <br>
 <br><b>grid</b> <b>dim(</b>rows columns 3<b>)</b> 
			values 0-255 <br>
 <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="format jpeg @in">format jpeg @in</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 <p>Support for RGB non-progressive</p> <br><b>method</b> open jpeg file <b>(</b><i>symbol</i> filename<b>)</b>   
			opens the specified file, taken from the current 
			directory or one of the jMax-specified data directories. <br>
 <br><b>grid</b> <b>dim(</b>rows columns 3<b>)</b> 
			values 0-255 <br>
 <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="format mpeg @in">format mpeg @in</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/format_mpeg.png" alt="[open mpeg file filename.mpeg]" border="0"><br clear="left"><br><br><br clear="left"><br></td><td><br>
  <p>Support for MPEG Video Stream only. 
		Does not support MPEG System Stream (that is, 
		files that contain both audio and video). </p> <p>Can only open one file at once (libmpeg.so limitation). 
		May scream error messages in a rude way. </p> <p>By opposition to PPM and TARGA, this format driver only 
		allows a single MPEG stream per file (you cannot "cat" 
		several MPEG files together). </p> <p>Rewind / Frame Select not supported. </p> <br><b>method</b> open mpeg file <b>(</b><i>symbol</i> filename<b>)</b>   
			opens the specified file, taken from the current 
			directory or one of the jMax-specified data directories. <br>
 <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="format grid @in/@out">format grid @in/@out</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/format_grid.png" alt="[open grid file filename.grid]" border="0"><br clear="left"><br><br><br clear="left"><br></td><td><br>
    <p> 
		This is GridFlow's special file format. This is the only I/O 
		format that can hold absolutely anything that the [@store] object can. 
		However this can only be stored in 32 bits-per-value. </p> <p> 
		This is the only picture format that currently supports TCP 
		connections. This is still somewhat clunky: the socket only 
		opens in client mode only; and upon bang, jMax freezes until 
		the whole grid is received. </p> <br><b>method</b> open grid file <b>(</b><i>symbol</i> filename<b>)</b>   
			opens the specified file, taken from the current 
			directory or one of the jMax-specified data directories. <br>
 <br><b>method</b> open grid gzfile <b>(</b><i>symbol</i> filename<b>)</b>   
			same but for .ppm.gz files <br>
 <br><b>method</b> open grid tcp <b>(</b><i>symbol</i> hostname<b>, </b><i>integer</i> port<b>)</b>    
			dials an specified hostname/port on the InterNet or 
			compatible network. the TCP protocol is used. <br>
 <br><b>method</b> open grid tcpserver <b>(</b><i>integer</i> port<b>)</b>   
			waits for a call (and answers) for this port on the 
			local machine via InterNet or compatible network. 
			Answers the call. <br>
 <br><b>method</b> option type int32 <b>(</b><b>)</b>  
			output will be as 32 bit signed integers. <br>
 <br><b>method</b> option type uint8 <b>(</b><b>)</b>  
			output will be as 8 bit unsigned integers. <br>
 <br><b>method</b> option headerful <b>(</b><b>)</b>  
			cancels option headerless (and back to reading .grid) <br>
 <br><b>method</b> option headerless <b>(</b>dimensions...<b>)</b>   
			instead of reading .grid files with header, will read raw data, 
			faking a .grid header to itself. It will use the hereby specified 
			dimension list, as well as two other settings: <kbd>option type</kbd> and <kbd>option endian</kbd>. <br>
 <p>When writing "raw" data, a file may be considered a long string of 
		base 256 digits (called bytes), but different computers have different 
		conventions for dealing with them: <br><b>method</b> option endian big <b>(</b><b>)</b>  
			A number will be written starting with the biggest digit. 
			This is the natural way on the Macintosh, Sun, Amiga, and so on. <br>
 <br><b>method</b> option endian little <b>(</b><b>)</b>  
			A number will be written starting with the smallest digit. 
			This is the natural way on the Intel 386/Pentium. <br>
 <br><b>method</b> option endian same <b>(</b><b>)</b>  
			A number will be written in whichever way is more natural 
			on this computer. The natural way is slightly faster to handle. 
			This is the default setting. <br>
 </p> <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="format videodev @in">format videodev @in</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/format_videodev.png" alt="[open videodev /dev/video0]" border="0"><br clear="left"><br><br><br clear="left"><br></td><td><br>
  <br><b>method</b> open <b>(</b>device<b>)</b>   <br>
 <br><b>method</b> open noinit <b>(</b>device<b>)</b>   
			This is the same except it is gentle with bad-tempered drivers. <br>
 <p>Video4Linux-1 devices, RGB-24 only. Variable picture size. 
		should work for bttv based cards and the dc1/dc10plus from Miro.</p> <p>If you suffer from color inversion, you may feed the list 
		"<kbd>3 3 # 0 0 1 0 1 0 1 0 0</kbd>" to the right side of a <kbd>[@inner2 * + 0]</kbd>. 
		Use that @inner2 object as a RGB-BGR converter.</p> <p>color adjustments: <br><b>method</b> option brightness <b>(</b><i>0-65535</i> level<b>)</b> <br>
 <br><b>method</b> option hue <b>(</b><i>0-65535</i> level<b>)</b> <br>
 <br><b>method</b> option colour <b>(</b><i>0-65535</i> level<b>)</b> <br>
 <br><b>method</b> option contrast <b>(</b><i>0-65535</i> level<b>)</b> <br>
 <br><b>method</b> option whiteness <b>(</b><i>0-65535</i> level<b>)</b> <br>
 </p> <p>other options: <br><b>method</b> option channel <b>(</b><i>integer</i> <b>)</b> <br>
 <br><b>method</b> option tuner <b>(</b><i>integer</i> <b>)</b> <br>
 <br><b>method</b> option norm <b>(</b><i>integer</i> <b>)</b> <br>
 <br><b>method</b> option frequency <b>(</b><i>integer</i> <b>)</b> <br>
 <br><b>method</b> option transfer mmap <b>(</b><b>)</b>  
			This is the normal (and fast) way of transferring pictures 
			from the camera. <br>
 <br><b>method</b> option transfer read <b>(</b><b>)</b>  
			Some cameras/drivers only support this instead of mmap. <br>
 <br><b>method</b> option size <b>(</b>height<b>, </b>width<b>)</b>    
			sets the input size, especially when using a video digitalizer 
			device <br>
 </p> <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="format sdl @out">format sdl @out</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 <br><b>method</b> open <b>(</b><b>)</b>  
			opens a dim(480,640,3) rgb window. <br>
 <br><b>grid</b> <b>dim(</b>rows columns {red green blue}<b>)</b> 
			sends frame to screen. window is NOT resized. <br>
 <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="format x11 @in/@out">format x11 @in/@out</a></td></tr><tr><td></td><td valign='top'><br>
<img src="images/format_x11.png" alt="[open x11 here]" border="0"><br clear="left"><br><br><br clear="left"><br></td><td><br>
   <br><b>method</b> open x11 <b>(</b><b>)</b>  
			synonym of "open x11 here". <br>
 <br><b>method</b> open x11 here <b>(</b><b>)</b>  
			connects to the default X11 server, 
			according to your environment variable "DISPLAY". <br>
 <br><b>method</b> open x11 local <b>(</b><i>integer</i> display_number<b>)</b>   
			connects to a display server on this machine. <br>
 <br><b>method</b> open x11 remote <b>(</b><i>symbol</i> host_name<b>, </b><i>integer</i> display_number<b>)</b>    
			connects to a remote X11 display server using TCP. 
			Sorry, IP addresses are not supported (jMax limitation). 
			Port number will be 6000 plus the display number, because 
			of the X11 standard. <br>
 <br><b>grid</b> <b>dim(</b>rows columns {red green blue}<b>)</b> 
			resizes the window to the size of the grid; 
			encodes that grid in the display's pixel format; 
			also displays it if autodraw > 0 
			the values must be in range 0-255, 
			or else they will be "wrapped". <br>
 <p> 
		Destroying the object (or sending "close") should close the window. 
		Because of how jMax works, 
		this may be delayed until you do something else. </p> <p>because of the design of Xlib, or if any of the connections 
		involved crashes, then the whole program (fts) has to be terminated. 
		(don't you love xlib). Something similar happens if you close any 
		of the windows yourself, but IIRC this could be fixed.</p> <p>only one window may be used per connection (to simplify matters; 
		this doesn't reduce flexibility).</p> <p>there is an additional argument that may be added to every 
		"open" message; if you don't put it, a new toplevel window is created. 
		if you put "root" then the screen's wallpaper will be used instead 
		(it may fail to work with some popular window managers). You can also 
		put a window number, e.g. <kbd>0x28003ff</kbd>, you may connect to 
		an existing window; you can find out the number of a window by using 
		a tool like <kbd>xwininfo</kbd>, part of X11 standard tools.</p> <br><b>method</b> option out_size <b>(</b><i>integer</i> height<b>, </b><i>integer</i> width<b>)</b>    
			changes the window's size, just like sending a grid 
			dim(height,width,3) would. <br>
 <br><b>method</b> option draw <b>(</b><b>)</b>  
			forces a redraw of the window's contents. <br>
 <br><b>method</b> option autodraw <b>(</b><i>0,1,2</i> level<b>)</b>   <ul> <li><b>0</b> : option draw() is never automatically invoked</li> <li><b>1</b> : option draw() is invoked after each grid is finished</li> <li><b>2</b> : option draw() is invoked incrementally after each row is 
			received. (but buffering may cause lines to come in groups 
			anyway)</li> </ul> <br>
 <br><b>method</b> option setcursor <b>(</b><i>0..63</i> cursor<b>)</b>   
			Selects one of the 64 predefined cursors of X11. (Note that if 
			your cursor table has them numbered from 0 to 126 using only even 
			numbers, then those cursor numbers are all doubled compared to 
			the ones GridFlow uses.) <br>
 <br><b>method</b> option hidecursor <b>(</b><b>)</b>  
			This makes the cursor invisible. <br>
  <br><b>outlet 0</b> <b>method</b> position <b>(</b><i>integer</i> y<b>, </b><i>integer</i> x<b>, </b><i>integer</i> buttons<b>)</b>     
				This is emitted every time the cursor moves inside 
				the window connected to this format handler. This is also 
				emitted when the cursor is dragging from inside to outside 
				the window. The y and x coordinates are relative to the upper 
				right corner of the window. Specific button states may be 
				extracted from the button value by applying [>> 
				buttonnumber] and then checking whether the result is odd. 
				Button numbers normally are: <ul> <li><b>0</b> : Shift</li> <li><b>1</b> : CapsLock</li> <li><b>2</b> : Control</li> <li><b>3</b> : Alternate</li> <li><b>4</b> : NumLock</li> <li><b>5</b> : ???</li> <li><b>6</b> : Meta</li> <li><b>7</b> : ScrollLock</li> <li><b>8</b> : Left Button</li> <li><b>9</b> : Middle Button</li> <li><b>10</b> : Right Button</li> <li><b>11</b> : Wheel Up</li> <li><b>12</b> : Wheel Down</li> </ul> <br>
  <br></td> 
<tr><td>&nbsp;</td></tr>
 
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><a name="Objects_for_Scripting"></a><h4>Objects for Scripting</h4></td></tr> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="ruby class FObject extending Data">ruby class FObject extending Data</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		Provides inlets and outlets to Ruby Objects. <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="ruby class GridObject extending FObject">ruby class GridObject extending FObject</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		Provides grid support to FObjects. <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="ruby class BitPacking">ruby class BitPacking</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		A BitPacking is a simple two-way converter between different 
		numeric layouts. <br></td> 
<tr><td>&nbsp;</td></tr>
 
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><a name="Objects_for_Internals"></a><h4>Objects for Internals</h4></td></tr> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="C++ class GridInlet">C++ class GridInlet</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		GridInlets represent inlets that accept grids. <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="C++ class GridOutlet">C++ class GridOutlet</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		GridOutlets represent outlets that send grids. <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="C++ class Dim">C++ class Dim</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		Dim represents a list of dimensions. <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="C++ class Grid">C++ class Grid</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		Grid represents a grid that is fully stored in memory. <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="C++ class Operator1">C++ class Operator1</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		This represents a one-input operator. <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="C++ class Operator2">C++ class Operator2</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		This represents a two-input operator. <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="C++ class GridClass">C++ class GridClass</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		This represents a class of GridObjects. <br></td> <tr><td colspan="4" bgcolor="#ffb080"><b>&nbsp;&nbsp;class </b><a name="C++ class GFBridge">C++ class GFBridge</a></td></tr><tr><td></td><td valign='top'><br>
<br clear="left"><br><br><br clear="left"><br></td><td><br>
 
		This holds linkage information about jMax and PureData and such. <br></td> 
<tr><td>&nbsp;</td></tr>
 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr> 
<td colspan="4"> 
<p><font size="-1">GridFlow 0.6.4 Documentation<br>
by Mathieu Bouchard <a href="mailto:matju@sympatico.ca">matju@sympatico.ca</a> 
and<br>
Alexandre Castonguay <a href="mailto:acastonguay@artengine.ca">acastonguay@artengine.ca</a></font></p>
</td>
</tr>
</table>
</body>
</html>


