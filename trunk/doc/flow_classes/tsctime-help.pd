#N canvas 508 124 568 545 10;
#X obj 0 0 doc_h;
#X obj 3 297 doc_c;
#X obj 0 516 doc_f;
#X obj 3 496 doc_also;
#X obj 3 421 doc_o 1;
#X obj 3 337 doc_i 2;
#X obj 14 367 doc_ii 0;
#X obj 14 389 doc_ii 1;
#X obj 14 451 doc_oo 0;
#X obj 97 367 doc_m i0 bang;
#X obj 97 389 doc_m i1 bang;
#X obj 97 451 doc_m o0 float;
#X text 200 367 reset timer;
#X text 200 389 trigger output;
#X obj 103 481 realtime;
#X obj 11 96 tsctime;
#X text 188 38 This is a super-high-resolution version of the [realtime]
class that does not look at the ordinary clock of the operating system
\, and instead uses the clock tick of the CPU itself. However \, if
you have a variable-clock CPU \, this will give you some kind of virtual
time.;
#X msg 50 45 bang;
#X msg 11 45 bang;
#X floatatom 14 122 10 0 0 0 - - -;
#X obj 78 100 realtime;
#X floatatom 78 122 10 0 0 0 - - -;
#X text 190 114 It's also possible that this has some other bugs related
to scaling. However \, even if it gives you really weird values \,
this object will give you very precise values in what is really the
wrong scale.;
#X text 192 171 if you are trying to measure real time with this \,
you should disable any CPU energy saving that may change the CPU's
clock speed. However \, if you want to measure CPU usage \, [tsctime]
is the ONLY of the time-objects to allow you to measure CPU usage reliably
while your clock speed changes.;
#X text 192 255 in assembly language \, [tsctime] is called "RDTSC"
\, and this is where [tsctime] got its name from.;
#X text 200 451 value in "milliseconds" (or lousy imitation thereof...
see intro text above.);
#X connect 3 1 14 0;
#X connect 9 1 12 0;
#X connect 10 1 13 0;
#X connect 11 1 25 0;
#X connect 15 0 19 0;
#X connect 17 0 15 1;
#X connect 17 0 20 1;
#X connect 18 0 15 0;
#X connect 18 0 20 0;
#X connect 20 0 21 0;
