	<class name="#checkers">
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {y x})"/>
				result from a [#for {0 0} {height width} {1 1}]
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				checkered pattern of 50%/75% greys
				in 8x8 squares
			</method>
		</outlet>
	</class>

	<class name="#layer">
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b a})"/>
				a picture that has an opacity channel.
				will be used as foreground.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				a picture that has NO opacity channel.
				will be used as background.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				a picture that has NO opacity channel.
				the opacity channel of the foreground is used as
				a weighting of how much of either picture is seen
				in the result.
			</method>
		</outlet>
	</class>

	<class name="#text_to_image">
		inlet 2 receives a font grid, for example, [#in grid file lucida-typewriter-12.grid.gz]
		inlet 1 receives a 2 by 3 matrix representing the colours to use (e.g. (2 3 # 0 170 0 255 255 0) means yellow on green)
		inlet 0 receives a bang, transforming the data into an image suitable for #draw_image.
	</class>
	<class name="#hueshift">
		inlet 1 receives an angle (0..36000)
		inlet 0 receives a RGB picture that gets hueshifted by a rotation in the colorwheel by the specified angle; it gets sent to outlet 0.
	</class>
	<class name="pingpong">
		Transforms linear counting (0, 1, 2, 3, 4, ...)  into a back-and-forth counting (0, 1, 2, 1, 0, ...)
		from 0 to a specified upper bound.
		<method name="init">
			<arg name="top" type="int"/>
		</method>
		<inlet id="1">
			<method name="float"><arg name="top" type="float"/></method>
		</inlet>
		<inlet id="0">
			<method name="float">
				a value to be transformed.
				If, for example, top=10, then values 0 thru 10 are left unchanged,
				values 11 thru 19 are mapped to 9 thru 1 respectively, and 20 thru 30
				are mapped to 0 thru 10, and so on.
			</method>
		</inlet>
	</class>
	<class name="fps">
		<method name="init">
			<arg name="clocktype" type="symbol(real|user|system|cpu)">
				which clock to use. "real" uses wallclock time. "user" uses
				the amount of time spent in the process. "system" uses the
				amount of time spent in the kernel on behalf of the process.
				"cpu" uses the Pentium clock, which is like a more precise
				version of "real" if you have a Pentium.
			</arg>
			<arg name="detailed" type="symbol(detailed)">optional</arg>
		</method>
		<method name="init detailed">
		</method>
		<inlet id="0">
			<method name="bang">
			Times at which bangs are received are stored until a large
			enough sample of those is accumulated. Large enough is defined
			to be whenever the timespan exceeds one second. Then a report
			is made through the outlet.
			</method>
			<method name="(else)">
				messages other than bangs are ignored.
			</method>
		</inlet>
		<outlet id="0">
			<method name="float">
			non-detailed mode only.
			this is the messages-per-second rating.
			</method>
			<method name="list(float,6)">
			detailed mode only.
			this is: messages-per-second, followed by five values of
			milliseconds-per-message: minimum, median, maximum, average,
			standard deviation.
			(the average happens to be simply 1000 divided by the
			messages-per-second, but it is convenient to have it anyway)
			</method>
		</outlet>
	</class>
	<class name="fork">
		Every incoming message is sent to inlet 1 and then sent to
		inlet 0 as well. Messages remain completely unaltered. Contrast
		with PureData's "t a a" objects, which have the same purpose but
		transform bangs into zeros and such.

		<inlet id="0"><method name="(any)"/></inlet>
		<outlet id="0"/>
		<outlet id="1"/>
	</class>
	<class name="foreach">
		<inlet id="0"><method name="list"><rest/>
			Outputs N messages, one per list element, in order.
		</method></inlet>
	</class>
	<class name="listreverse">
		<inlet id="0"><method name="list"><rest/>
			Outputs the incoming list, from last element to first element.
		</method></inlet>
	</class>
	<class name="range">
		<method name="init">
			<rest name="separators" type="float"></rest>
		</method>
		<inlet id="0"><method name="float">
			a value to be sent to one of the outlets. The first outlet is for values
			smaller than the first argument; else the second outlet is for values smaller
			than the second argument; and so on; and the last outlet is for values greater
			or equal to the last argument.
		</method></inlet>
		<inlet id="1..n"><method name="float">
			sets the corresponding separator in the separator list.
		</method></inlet>
	</class>
	<class name="#centroid">
		<method name="init"/>
		<inlet id="0"><method name="grid(rows,columns,1)">
			will compute the centroid of the given grid, which
			is a weighted average, namely, the average position weighted
			by the pixel values.
		</method></inlet>
		<outlet id="0">
			<method name="grid(2)">
			result
			</method>
		</outlet>
	</class>
