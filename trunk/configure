#!/usr/bin/env ruby
# $Id$
=begin
	GridFlow
	Copyright (c) 2001-2007 by Mathieu Bouchard

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	See file ./COPYING for further informations on licensing terms.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
=end

require "rbconfig"
require "ftools"
$CFLAGS  = ""
$LDFLAGS = ""
include Config
OSX = !!( CONFIG["arch"] =~ /darwin/ )

require "win32/process" if CONFIG["arch"] =~ /mingw/
LOG = File.open "./config.log", "w"

Red   = "\e[0;1;31m"
Green = "\e[0;1;32m"
Light = "\e[0m"
Dark  = "\e[0;1;30m"
Yellow = "\e[0;1;33;44m"

$verbose=false
LOG.puts "-"*64
LOG.puts "Environment Variables: "
ENV.each {|k,v| LOG.puts "#{k}=#{v}" }
LOG.puts "-"*64

puts
if not File.exist?("./configure")
	puts "Run me from the right directory please."
	exit 1
end

begin Dir.mkdir "tmp"; rescue Errno::EEXIST; end

#----------------------------------------------------------------#

class Or
	attr_reader :a
	class<< self; alias [] new end
	def initialize(*a) @a=a end
	def to_s; @a.join " or "; end
end

def launch2(log,*command)
	log << command.join(" ") << "\n"
	r,w = IO.pipe
	child = launch(nil,w,w,*command)
	w.close
	log << r.readlines.join << "\n"
	ret = join_pid(child)
	ret = ret.to_int if RUBY_VERSION > "1.7"
	log << "error \##{ret}\n" if ret>0
	return ret<=0
end

$conf={
	:LDSOFLAGS => ["-lm"],
	:BRIDGE_LDFLAGS => ["-lm"],
	:FEATURES => {},
	:OPTIONS => [],
	:DEFINES => {
		:CPU => nil,
		:GEM_SOURCE => "../Gem/src",
	},
	:CC => "g++",
	:OBJS => [],
}

def launch stdin,stdout,stderr,*command # -> returncode
	child = fork
	if not child then
		STDIN .reopen stdin  if stdin
		STDOUT.reopen stdout if stdout
		STDERR.reopen stderr if stderr
		exec *command
		#!@#$ what happens with exception upon exec ?
	end
	child
end

def join_pid pid
	Process.waitpid2(pid)[1]
end

module Future; end

class Feature
	$features = []
	def self.add(*a,&b) $features << Feature.new(*a,&b) end
	def initialize(&b) instance_eval(&b) end
	def self.attr2(sym,&b)
		eval "def #{sym}(*args,&b)
			raise args.inspect if args.length>1
			if b then @#{sym}=b.extend Future
			elsif args.length>0 then @#{sym}=args[0]
			else if Future===@#{sym} then @#{sym}.call else @#{sym} end end end"
	end
	attr2 :tag
	attr2 :name
	attr2 :status
	attr2 :uses_so
	attr2 :uses_bridge_so
	attr2 :uses_o
	attr2 :uses_h
	attr2 :uses_feature
	attr2 :test
	attr2 :options
	attr2 :unless_feature
	attr2 :action
	attr2 :defines

	def find_h name
		if name[0..0]=="/" then
			File.exist?(name)
		else
			$C_INCLUDE_PATH.find {|x| File.exist?(x+"/"+name)}
		end
	end

	def c_test code, link=nil, options=[], feature=nil
		link = (uses_so||[]).dup if not link
		link=link.flatten
		ldlpath = ENV["LD_LIBRARY_PATH"]
		uses_h.each {|h|
			find_h h or
				/framework/ =~ (uses_so||[]).join(" ") or
				raise "where is #{h} ?"
		} if uses_h
		ENV["LD_LIBRARY_PATH"] = ldlpath ? "./tmp:#{ldlpath}" : "./tmp"
		link[0,0]=$conf[:LDSOFLAGS].find_all {|x| String===x and /^-L/ =~ x }.flatten
		code=code.gsub(/#include#/) {
			uses_h.map {|inc| "#include <#{inc}>\n" }.join""
		}	
		log = ""
		log << code << "\n"
		binname = "tmp/#{$$}"
		sourcename = binname+".cpp"
		File.open(sourcename,"w") {|f| f.puts code }
		command = ["/usr/bin/env", $conf[:CC]] +
			$CFLAGS.split(/ /).reject{|x| x.length==0 }
		if not launch2 log,*(command+options+[sourcename,
			 "-o", binname, *link])
			pat = Regexp.new("^"+Regexp.quote(sourcename)+":\\d+: ")
			errs = log.split("\n").find_all {|l| pat =~ l }
			raise "gcc compilation error" if not errs or
				errs.length==0
			errs = errs[0].gsub(pat,"")
			raise "gcc: #{errs}"
		end
		if not launch2 log,"tmp/#{$$}"
			raise "runtime error"
		end
		return true
	ensure
		LOG.puts log
		ENV["LD_LIBRARY_PATH"] = ldlpath if ldlpath
	end

	def asm_test code, *link
		log = ""
		log << code << "\n"
		File.open("tmp/#{$$}.asm","w") {|f| f.puts code }
		command = ["/usr/bin/env", "nasm",
		"tmp/#{$$}.asm", "-f", "elf", "-o", "tmp/#{$$}.o"]
		launch2 log,*command or return false
		command = ["#{$conf[:CC]}","-o","tmp/#{$$}","tmp/#{$$}.o",*link]
		launch2 log,*command or return false
		command = ["tmp/#{$$}"]
		launch2 log,*command or return false
		true
	ensure
		LOG.puts log
	end
end

#----------------------------------------------------------------#

def make_expand(x)
  y=x.gsub(/\$\(([^\)]*)\)/) {CONFIG[$1]}
  if x!=y then make_expand y else y end
end

def read_ld_so_conf
	return [] unless File.exist?("/etc/ld.so.conf")
	x = File.open("/etc/ld.so.conf"){|f| f.read }.split("\s")
	x.delete_if { x.length==0 }
	x
end

def epath x; (ENV[x]||"").split(":") end

$C_INCLUDE_PATH = (
	epath("CPLUS_INCLUDE_PATH") +
	epath("C_INCLUDE_PATH") +
	["/usr/include"]).uniq

$LIBRARY_PATH = (
	epath("LIBRARY_PATH") +
	["/usr/lib","/lib"]).uniq

$LD_LIBRARY_PATH = (
	epath("LD_LIBRARY_PATH") +
	read_ld_so_conf +
	["/usr/lib","/lib"]).uniq
$LIBX11DIR = [
  "-L/usr/X11R6/lib",  "-L/opt/gnome/lib",
  "-L/usr/X11R6/lib64","-L/opt/gnome/lib64"]
$LIBX11 = $LIBX11DIR + ["-lX11"]

# making it easier for everybody I hope:
def prepend_path base
	bl = base+"/lib"
	bi = base+"/include"
	if not $LD_LIBRARY_PATH.include? bl and
	   not $LIBRARY_PATH.include? bl then
		$conf[:LDSOFLAGS].unshift "-L"+bl
		$LD_LIBRARY_PATH.unshift bl
		$LIBRARY_PATH.unshift bl
	end
	#and not $CPLUS_INCLUDE_PATH.include? bi
	if not $C_INCLUDE_PATH.include? bi then
		$CFLAGS += " -I"+bi
		$C_INCLUDE_PATH.unshift bi
	end
end
prepend_path "/sw" if OSX
prepend_path "/usr/local"
prepend_path ENV["HOME"]
$CFLAGS += " -I."
$C_INCLUDE_PATH.unshift "."


for var in [:$C_INCLUDE_PATH, :$LIBRARY_PATH, :$LD_LIBRARY_PATH] do
	LOG.puts "#{var}: #{eval(var.to_s).inspect}"
end

LOG.puts "-"*64

$CFLAGS += " -xc++ -fno-operator-names -fno-omit-frame-pointer"
$CFLAGS += " -I/usr/X11R6/include"
$C_INCLUDE_PATH.unshift "/usr/X11R6/include"

ruby16a = "#{CONFIG['libdir']}/ruby/#{CONFIG['MAJOR']}.#{CONFIG['MINOR']}/"\
"#{CONFIG['arch']}/#{CONFIG['LIBRUBY_A']}"		
ruby18a = "#{CONFIG['libdir']}/#{CONFIG['LIBRUBY_A']}"
for x in [ruby16a,ruby18a] do
	$LIBRUBY_A = make_expand x
	break if File.exist? $LIBRUBY_A
end

#----------------------------------------------------------------#
Feature.add {
	tag :gcc3
	name "GNU C++ Compiler 3 (or 4)"
	options ["HAVE_GCC3"]
	test proc {
		pi=File.popen "#{$conf[:CC]} -v 2>&1", "r"
		vline = pi.readlines.find {|l| /gcc version ([\d\.]+)/.match l }
		version = $1
		pi.close
		if version < "3" then raise "version #{version} < 3" end
		true
	}
	test proc {
		c_test %{
		#include <stdio.h>
		int main () {
			printf("GCC_VERSION %d.%d.%d\\n", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);
			return !(__GNUC__>=3);
		}}
	}
	defines :GCC_VERSION => proc {
		m = /GCC_VERSION\s+(.*)/.match(File.popen("tmp/#{$$}","r"){|f| f.read })
		m[1]
	}
}
Feature.add {
	tag :stl
	name "C++ Standard Template Library"
	test proc {
		c_test %{
		#include <vector>
		int main () {
			std::vector<int> foo;
		}}
	}
}
Feature.add {
	tag :gcc64
	name "GNU C++ in 64-bit mode"
	options ["GCC64"]
	test proc {
		c_test %{
		#include <stdio.h>
		#include <stdlib.h>
		#include <cstddef>
		#define T(a) printf("%s:%ld; ",#a,(long)sizeof(a));
		int main () {
			T(void *)T(ptrdiff_t)T(off_t)T(size_t)puts("");
			T(char)T(short)T(int)T(long)T(long long)puts("");
			T(float)T(double)puts("");
			return !( sizeof(void*)==8 );
		}}
	}
}

#----------------------------------------------------------------#
Feature.add {
	tag :libruby
	name "Ruby as a dynamic library"
	#uses_bridge_so [CONFIG["LIBRUBY_DLDFLAGS"]]
	#uses_h ["ruby.h"] # is in special directory
	test proc {|f| c_test "#include <ruby.h>
		int main () { return rb_rescue==0; }", f.uses_bridge_so }
}
Feature.add {
	tag :librubystatic
	unless_feature [:libruby]
	name "Ruby as a static library"
	#uses_h ["ruby.h"] # is in special directory
	uses_bridge_so {
		lib = " #{$LIBRUBY_A} #{CONFIG['LIBS']} "
			lib = "-Wl,--whole-archive"+lib+"-Wl,--no-whole-archive" unless OSX
		[lib]
	}
	test proc { c_test "#include <ruby.h>
		int main () { return rb_rescue==0; }",
		["-xnone", $LIBRUBY_A, *(CONFIG['LIBS'].split)] }
	options ["HAVE_STATIC_RUBY"] #!@#$ useless?
}

File.popen("tclsh","r+") {|f|
  f.puts %{puts $tcl_version}
  $tcl_version = f.gets.chomp
}
#STDERR.puts "$tcl_version = #{$tcl_version}"

Feature.add {
	tag :libtclh
	name "Tcl headers"
	uses_h Or[["tcl.h"],
		["tcl8.5/tcl.h"],
		["tcl8.4/tcl.h"],
		["tcl8.3/tcl.h"]]
	test proc {|f|
		r = f.c_test "
			#include#
			int main () {return 0;}"
		if r==true
			$TCLH = f.find_h(f.uses_h[0])+"/"+f.uses_h[0]
			$CFLAGS += " -I"+File.dirname($TCLH)
			#STDERR.puts "$TCLH = #{$TCLH}"
		end
		r
	}
}
Feature.add {
	tag :libtcl
	name "Tcl as a dynamic library"
	uses_h []
	uses_so ["-L/usr/lib","-ltcl"+$tcl_version]
	test proc { c_test "
		#include <tcl.h>
		int main () {Tcl_CreateInterp(); return 0;}
	" }
}

#----------------------------------------------------------------#
Feature.add {
	tag :pentium
	name "Pentium-compatible CPU"
	action proc { $conf[:DEFINES][:CPU] ||= "pentium" }
	test proc {
		(CONFIG["arch"] =~ /(i\d86|x86_64)/) or raise "#{CONFIG["arch"]} instead"
		c_test '
		#include <stdio.h>
		char get_cpuid[]={
			96,49,192,15,162,139,124,36,36,137,31,
			137,87,4,137,79,8,137,71,12,97,195};
		main() {
			char result[16];
			int code;
			((void(*)(char*))get_cpuid)(result);
			code = ((int*)result)[3];
			result[12]=0;
	                fprintf(stderr,"cpuid: name=\"%12s\", flags=0x%08x\n",
	                        result,code);
			return 0;}'
	}
	options ["HAVE_PENTIUM"]
}
Feature.add {
	tag :mmx
	uses_feature [:pentium]
	uses_o ["base/mmx.o","base/mmx_loader.o"]
	name "MMX-compatible CPU (using NASM)"
	test proc { #!@#$ isn't 64-bit-compatible
		asm_test '
		global main
		extern exit
		align 16
		SECTION .data
		foo: dd 42,0
		SECTION .text
		main:
		lea esi,[foo]
		movq mm0,qword[esi]
		paddd mm0,qword[esi]
		movq qword [esi],mm0
		emms
		cmp dword [foo], 84
		je yes
		push long 1
		call exit
		yes:
		push long 0
		call exit
		', '-lc'
	}
	options ["HAVE_MMX"]
}
#----------------------------------------------------------------#
Feature.add {
	tag :usb
	name "USB Library"
	uses_h ["usb.h"]
	uses_o ["optional/usb.o"]
	uses_so ["-lusb"]
	test proc {
		c_test "
		#include#
		int main () {return usb_open==0 || usb_get_busses==0;}
		"
	}
	options ["HAVE_USB"]
}
#----------------------------------------------------------------#
=begin
Feature.add {
	tag :dv1394
	name "DV1394 for Linux"
	uses_so ["-ldv"]
	uses_h ["format/dv1394.h"]
	test proc {
		c_test "
		#include#
		int main () {return 0;}
		"
	}
	options ["HAVE_DV1394"]
	uses_o ["format/dv1394.o"]
}
=end
Feature.add {
	tag :x11
	name "X11 Display Protocol"
	uses_so $LIBX11
	uses_h ["X11/Xlib.h"]
	test proc {
		c_test "
		#include#
		int main () {return XSetErrorHandler==0;}
		"
	}
	uses_o ["format/x11.o"]
}
Feature.add {
	tag :x11_shm
	name "X11 acceleration by shared memory (XSHM plugin)"
	uses_feature [:x11]
	uses_so $LIBX11+["-lXext"]
	uses_h ["X11/Xlib.h","sys/shm.h","X11/extensions/XShm.h"]
	test proc {
		c_test "
		#include#
		#include <X11/Xutil.h>
		#include <X11/StringDefs.h>
		#include <sys/ipc.h>
		int main () {return XShmPutImage==0;}
		"
	}
	options ["HAVE_X11_SHARED_MEMORY"]
}
Feature.add {
	tag :sdl
	name "Simple Directmedia Layer (experimental support)"
	uses_so {
		a=["-lSDL","-lpthread"]
		a << "-lobjc" if OSX
		a
	}
	uses_h ["SDL/SDL.h"]
	test proc {
		c_test "
		#include#
		int main () {return SDL_MapRGB==0;}
		"
	}
	uses_o ["format/sdl.o"]
}
Feature.add {
	tag :objcpp
	name "GNU/Apple ObjectiveC++ Compiler"
	uses_h ["objc/Object.h"]
	uses_so ["-lobjc"]
	test proc {
		c_test "
		#include#
		int main () { [[Object alloc] init]; }
		", nil, ["-xobjective-c++"]
	}
}
Feature.add {
	tag :quartz
	name "Apple Quartz/Cocoa Display"
	uses_so ["-lobjc",["-framework","Cocoa"]]
	uses_feature [:objcpp]
	uses_h ["objc/Object.h","Cocoa/Cocoa.h"]
	test proc {
		c_test "
		#include#
		int main () {return CGImageRelease==0;}
		", nil, ["-xobjective-c++"]
	}
	uses_o ["format/quartz.o"]
}
Feature.add {
	tag :aalib
	name "Ascii Art Library"
	uses_so ["-laa"]
	uses_h ["aalib.h"]
	test proc {
		c_test "
		#define aa_hardwareparams aa_hardware_params
		extern \"C\" {
		#include#
		};
		int main () {return aa_init==0;}
		"
	}
	uses_o ["format/aalib.o"]
}
Feature.add {
	tag :jpeg
	name "JPEG Library"
	uses_so ["-ljpeg"]
	uses_h ["jpeglib.h"]
	test proc {
		c_test "
		extern \"C\" {
		#include <stdio.h>
		#include#
		};
		int main () {
		return jpeg_write_scanlines==0;}
		"
	}
	uses_o ["format/jpeg.o"]
}
Feature.add {
	tag :png
	name "PNG Library"
	uses_so ["-lpng","-lz"]
	uses_h Or[["libpng12/png.h"],["png.h"]]
	test proc {|f|
		f.c_test %`
		extern "C" {
		#include <stdio.h>
		#include#
		};
		int main () {
		#define T(a) printf("%s:%d; ",#a,sizeof(a));
		T(png_uint_32)T(long)puts("");
		if (!png_check_sig) return 1;
		return 0;}
		`
	}
	uses_o ["format/png.o"]
}
#------------------------------------------------#
Feature.add {
	tag :videodev
	name "Video4linux Digitizer Driver Interface"
	uses_h ["linux/videodev.h"]
	test proc {
		c_test "
		#include <stdlib.h>
		#include#
		int main () { struct video_window foo; return 0; }"
	}
	uses_o ["format/videodev.o"]
	#uses_o ["format/videodev-old.o"]
}
Feature.add {
	tag :mpeg3
	name "HeroineWarrior LibMPEG3"
	uses_so $LIBX11DIR+["-lmpeg3","-lpthread","-lm"]
	uses_h Or["libmpeg3/libmpeg3.h","libmpeg3.h"]
	test proc {|f|
		f.c_test "
		#include#
		int main () { return mpeg3_open==0; }
		"
	}
	uses_o ["format/mpeg3.o"]
}
Feature.add {
	tag :quicktimeapple
	name "Apple's QuickTime"
	uses_so [["-framework","Quicktime"]]
	uses_h ["QuickTime/QuickTime.h","QuickTime/Movies.h"]
	test proc {
		c_test "
		#include#
		int main () { return EnterMovies==0; }
		"
	}
	uses_o ["format/quicktimeapple.o"]
}
Feature.add {
	tag :quicktimehw
	unless_feature :quicktimeapple
	name "Plaum's LibQuickTime"
	uses_so Or[
		$LIBX11DIR+["-lquicktime","-lpthread","-lpng","-ldl","-lglib","-lz"],
		$LIBX11DIR+["-lquicktime","-lpthread","-lpng","-ldl","-lglib-1.2","-lz"]]
	f = ["quicktime.h","colormodels.h","lqt.h","lqt_version.h","lqt_codecinfo.h"]
	uses_h Or[
		f.map{|x| "lqt/"+x },
		f.map{|x| "quicktime/"+x }]
	test proc {|f|
		f.c_test %`
		#include <stdio.h>
		#include#
		int main () {
		fprintf(stderr,"LQT_VERSION = %s\\n",
		#ifdef LQT_VERSION
			LQT_VERSION
		#else
			"(undefined)"
		#endif
		); return quicktime_open==0; }
		`
	}
	uses_o ["format/quicktimehw.o"]
}
#----------------------------------------------------------------#
Feature.add {
	tag :puredata
	name "PureData (or DesireData)"
	uses_feature [Or[:libruby,:librubystatic]]
	options ["HAVE_PUREDATA"]
	defines {
		path = $C_INCLUDE_PATH.find {|x| File.exist?(x+"/m_pd.h")}
		m = /PD_VERSION_INT\s+(.*)/.match(File.popen("tmp/#{$$}","r"){|f| f.read })
		{:PD_VERSION_INT => m[1].to_i}
	}
	uses_h ["m_pd.h"]
	test proc {
		c_test %`
			#include#
			#include <stdio.h>
			int main () {
			printf("#define PD_VERSION_INT %d\\n",
			#ifdef PD_MAJOR_VERSION
				(int)(PD_MAJOR_VERSION*100+PD_MINOR_VERSION));
			#else
				(int)(PD_VERSION*100));
			#endif
			return 0;
			}
		`
	}
}
Feature.add {
	tag :desiredata
	name "DesireData"
	uses_h ["m_pd.h"]
	test proc {
		c_test %`
			#include#
			int main () { return !gobj_subscribe; }
		`
	}
	defines ["HAVE_DESIREDATA"]
}

#--------------------------------#
Feature.add {
	tag :gem09
	name "PureData GEM (source code) with m_holdname"
	uses_feature [:puredata]
	uses_o ["optional/gem.o"]
	options ["HAVE_GEM","HAVE_HOLDNAME"]
	test proc {
		# hack
		$C_INCLUDE_PATH.unshift $conf[:DEFINES][ :GEM_SOURCE]
		$CFLAGS += " -I"+$conf[:DEFINES][ :GEM_SOURCE]
		c_test %`
			#include "Base/GemBase.h"
			int main () {CPPExtern::m_holdname; return 0;}`
	}
}
Feature.add {
	tag :gem08
	unless_feature:gem09
	name "PureData GEM (source code) without m_holdname"
	uses_feature [:puredata]
	uses_o ["optional/gem.o"]
	options ["HAVE_GEM"]
	test proc {
		# hack
		$C_INCLUDE_PATH.unshift $conf[:DEFINES][ :GEM_SOURCE]
		$CFLAGS += " -I"+$conf[:DEFINES][ :GEM_SOURCE]
		c_test %`
			#include "Base/GemBase.h"
			int main () {return 0;}`
	}
}

#--------------------------------#
Feature.add {
	tag :fftw
	name "FFTW (Fastest Fourier Transform in the West)"
	uses_o ["optional/fftw.o"]
	uses_so ["-lfftw3f","-lfftw3"]
	options ["HAVE_FFTW"]
	test proc {
		c_test %`
			#include <fftw3.h>
			int main () {
				return 0;
			}
		`
	}
}
#--------------------------------#

$features_h = {}
$features.each {|f| $features_h[f.tag]=f }

def usage
	log = ""
	log << "usage: ./configure "
	log << "[--use-compiler compiler] [--use-compiler-option option]* "
	log << "[--use-cpu cpu] [--lite] [--debug]"
	log << "[--gem-source directory]"
	$features_h.keys.map {|k| k.to_s }.sort.each {|k| log << "[--no-#{k}] " }
	$features_h.keys.map {|k| k.to_s }.sort.each {|k| log << "[--force-#{k}] " }
	puts
	while log.length>0 do puts log.slice!(/^.{1,70} /) end
end

while ARGV.length>0 do
	arg=ARGV.shift
	case arg
	when /=/
		i=arg.index '='
		ARGV.unshift arg[0..i-1], arg[i+1..-1]
	when /^--no-/
		name = arg[5..-1].untaint.intern
		puts "there is no feature called #{name}" if not $features_h[name]
		puts "--no: won't check for feature #{name}"
		$features_h.delete name
	when /^--force-/
		name = arg[8..-1].untaint.intern
		puts "there is no feature called #{name}" if not $features_h[name]
		puts "--force: assuming #{name} is there"
		$features_h[name].test nil
	when "--static" # experimental
		$conf[:STATIC]=true
		$conf[:LDSOFLAGS] << "-static"
#		ARGV.unshift "--no-libruby"
	when "--debug"
		puts "Debug Mode (more error checking; less speed)"
		$conf[:OPTIONS].push :HAVE_DEBUG
		$CFLAGS += " -fno-inline"
	when "--lite"
		puts "Lite Mode (no float64, no int64)"
		$conf[:OPTIONS].push :HAVE_LITE
	when "--help"
		usage; exit 0
	when "--gem-source"
		 $conf[:DEFINES][ :GEM_SOURCE]=ARGV.shift
	when "--use-compiler"
		$conf[:CC] = ARGV.shift
	when "--use-compiler-option"
		$CFLAGS += " "+ARGV.shift
	when "--use-cpu"
		$conf[:DEFINES][:CPU] = ARGV.shift
	when "--verbose"
		$verbose=true
	else puts "unknown option \"#{arg}\""; usage; exit 1
	end
end

# the ||= lines are patches for old versions of ruby.
CONFIG["ruby_version"] ||= "$(MAJOR).$(MINOR)"
CONFIG["rubylibdir"] ||= "$(libdir)/ruby/$(ruby_version)"
CONFIG["archdir"] ||= CONFIG["rubylibdir"] + "/" + CONFIG["arch"]
$CFLAGS += " -I" + (make_expand CONFIG["archdir"])

#--------------------------------#

DUAL = Object.new
DUAL.instance_eval {
	def self.print x
		LOG   .puts  x; LOG   .flush
		STDERR.print x; STDERR.flush
	end
	def self.puts x
		self.print x+"\n"
	end
}

def try feature
	if Or===feature.uses_bridge_so
		k=1; feature.uses_bridge_so.a.each {|i|
			e=feature.dup; e.uses_bridge_so i; e.name(e.name+" (try \##{k})")
			r=try e; k+=1; return r if r }
		return false
	end
	if Proc===feature.uses_so then feature.uses_so(feature.uses_so[]) end
	if Or===feature.uses_so
		k=1; feature.uses_so.a.each {|i|
			e=feature.dup; e.uses_so i; e.name(e.name+" (try \##{k})")
			r=try e; k+=1; return r if r }
		return false
	end
	if Proc===feature.uses_h then feature.uses_h(feature.uses_h[]) end
	if Or===feature.uses_h
		k=1; feature.uses_h.a.each {|i|
			i=[i] if String===i
			e=feature.dup; e.uses_h i; e.name(e.name+" <#{i[0]}>")
			r=try e; k+=1; return r if r }
		return false
	end
	LOG.puts "", "-"*64
	line = "[#{feature.tag}] #{feature.name}: "
	DUAL.print Light + "[#{Yellow}#{feature.tag}#{Light}] #{feature.name}: "
	arrow = "-"*([78-line.length,0].max)+ "> "
	#DUAL.print Dark + arrow +Red
	(feature.uses_feature||[]).find {|f|
		if not (
		  if Or===f then f.a.find {|x| $conf[:FEATURES][x] } else $conf[:FEATURES][f] end
		) then 
			DUAL.puts Red+arrow+"disabled (would need #{f})"
			return
		end
	}
	if feature.status==:disabled then DUAL.puts Dark+arrow+"disabled (by author)"; return end
	if not $features_h[feature.tag] then DUAL.puts Dark+arrow+"disabled (by user)"; return end
	fu = feature.unless_feature || []
	fu = [fu] if not Array===fu
	for f in fu || [] do
		if $conf[:FEATURES][f] then
			DUAL.puts Dark+arrow+"disabled (using #{f} instead)"
			return
		end
	end

	if feature.test
		begin
			tresult = feature.test.call(feature)
		rescue StandardError => e
		end
		if tresult
			DUAL.puts Green+arrow+"found "+(if tresult!=true
				then " (#{tresult})"
				else "" end)
			if tresult == "static"
				feature.uses_so.map! {|x|
					"-Wl,--whole-archive #{x} -Wl,--no-whole-archive"
				} if feature.uses_so
				feature.uses_bridge_so.map! {|x|
					"-Wl,--whole-archive #{x} -Wl,--no-whole-archive"
				} if feature.uses_bridge_so
			end
		else
			DUAL.puts Red+arrow+"missing "+(if e
				then (if $verbose
					then "(#{e} @ #{e.backtrace.join', '})"
					else "(#{e})" end)
				else "(return false)" end)
			if e
				LOG.puts e.inspect
				LOG.puts e.backtrace
			end
			return false
		end
	else
		puts Green+arrow+"enabled"
		$conf[:FEATURES][feature.tag] = feature
		feature.action.call if feature.action
	end
	feature.action.call if feature.action
	$conf[:FEATURES][feature.tag] = feature
	$conf[:LDSOFLAGS].concat(feature.uses_so||[])
	$conf[:BRIDGE_LDFLAGS].concat(feature.uses_bridge_so||[])
	$conf[:OBJS].concat(feature.uses_o||[])
	$conf[:OPTIONS].concat(feature.options||[])
	for k,v in feature.defines||{} do
		$conf[:DEFINES][k]=(if Proc===v then v[] else v end)
	end
	true
end

DUAL.puts "This is the GridFlow 0.9.0 configurator within "+
	"Ruby version #{RUBY_VERSION}-#{RUBY_RELEASE_DATE}"

begin
  $features.each {|feature| try feature }
ensure
  #!@#$ note: see END{} (duplication)
  system "/bin/rm -f tmp/#{$$} tmp/#{$$}.c tmp/#{$$}.o tmp/#{$$}.asm"
end

puts Light

$conf[:LDSOFLAGS].uniq!
$conf[:BRIDGE_LDFLAGS].uniq!

$CFLAGS += " -falign-functions=16" if $conf[:FEATURES][:gcc3]

if not $conf[:FEATURES][:gcc3]
  puts "You should install gcc 3.x; gcc 2.9.x is no longer supported"
  puts "(you might use --force-gcc3 to pretend at your own risk)"
  exit 1
end

if not $conf[:FEATURES][:puredata]
  puts "PureData support is required (since GridFlow 0.9.0)"
end

#--------------------------------#

LOG.puts "-"*64
for z in [:BRIDGE_LDFLAGS, :LDSOFLAGS, :OPTIONS, :DEFINES, :OBJS] do
  LOG.puts "#{z}: #{$conf[z].inspect}"
end
LOG.puts "-"*64
RUBY = "$(RUBY_INSTALL_NAME)"

def my_install_files(f,base,entries,obase="$(sitelibdir)/gridflow/#{base}")
  entries.each {|type,name,*rest|
    if Array===name then name,oname=name else oname=name end
    case type
    when :ruby
      f.puts "\t$(INSTALL_DATA) #{base+name} #{obase}/#{oname}"
    when :directory
      if oname[0,1]!="/" then oname="#{obase}/#{oname}" end
      f.puts "\t$(INSTALL_DIR) #{oname}"
      my_install_files(f,base+name,rest,oname)
    end
  }
end

def my_uninstall_files(f,base,entries,obase="$(sitelibdir)/gridflow/#{base}")
  entries.each {|type,name,*rest|
    if Array===name then name,oname=name else oname=name end
    case type
    when :ruby
      f.puts "\trm #{obase}/#{oname}"
    when :directory
      my_uninstall_files(f,base+name,rest) 
    end
  }
end

puts "generating ./config.make"
File.open("./config.make","w") {|f|

  f.puts "RUBYARCH=#{CONFIG['arch']}"
  f.puts "BRIDGE_LDFLAGS = " + $conf[:BRIDGE_LDFLAGS].flatten.join(" ") + " " + $LDFLAGS

  $CFLAGS +=  " -mcpu=$(CPU)" if $conf[:DEFINES][:CPU] and $conf[:DEFINES][:GCC_VERSION] <  "4"
  $CFLAGS += " -mtune=$(CPU)" if $conf[:DEFINES][:CPU] and $conf[:DEFINES][:GCC_VERSION] >= "4"
  $CFLAGS += " -march=$(CPU)" if $conf[:DEFINES][:CPU]
  #$CFLAGS += " -fforce-addr"
  #$CFLAGS += " -fprefetch-loop-arrays"
  #$CFLAGS += " -falign-jumps=4"
  #$CFLAGS += " -falign-loops=4"
  $CFLAGS += " -DMACOSX" if OSX
  f.puts "CFLAGS += " + $CFLAGS
  f.puts "LDSOFLAGS += " + $conf[:LDSOFLAGS].flatten.join(" ")

  for k   in $conf[:OPTIONS] do f.puts "#{k}=yes" end
  for k,v in $conf[:DEFINES] do f.puts "#{k}=#{v}" end
  f.puts "CXX = #{$conf[:CC]}"
  f.puts "OBJS = #{$conf[:OBJS].join(" ")}"
  f.puts "DLEXT = #{CONFIG['DLEXT']}"
  f.puts ""

  if OSX then
    f.puts "OS = darwin"
  else
    f.puts "OS = linux"
  end

  for k in %w(LIBRUBY_DLDFLAGS LIBS LIBRUBYARG) do
    f.puts "#{k} = #{CONFIG[k]}"
  end

} # end open config.make

#--------------------------------#
puts "generating config.h"
File.open("config.h","w") {|f|
f.puts "
\#ifndef __CONFIG_H
\#define __CONFIG_H
/* this file was auto-generated by gridflow/configure */"
f.puts "#define STARTUP_LIST(PRE) \\"
f.puts $conf[:OBJS].map {|o|
	oo = File.basename(o,'.o').split(/-/)[0]
	"PRE startup_#{oo}();"
}.join("\\\n")
for k   in $conf[:OPTIONS] do f.puts "\#define #{k}" end
for k,v in $conf[:DEFINES] do f.puts "\#define #{k} "+v.inspect end

def include_here(f,a,b)
  return unless $conf[:FEATURES][b]
  f.puts "\#ifdef #{a}_INCLUDE_HERE"
  for inc in $conf[:FEATURES][b].uses_h.to_a do
    f.puts "\#include <#{inc}>"
  end
  f.puts "\#endif"
end
include_here f,"TCL", :libtclh
include_here f,"LIBMPEG", :mpeg3
include_here f,"QUICKTIMEHW",:quicktimehw

f.puts "
\#endif /* __CONFIG_H */"
} # end open config.h

#--------------------------------#
for s in [
"See ./config.log if you want the details of the configuration tests.",
"If you are satisfied with that configuration, you may go on,",
"and do \"make\". \"make install\" is not needed anymore,",
"just move your gridflow directory to \"lib/pd/extra\".",
"If you get stuck, you could contact the author about it,",
"but first make sure you read \"doc/install.html\". ",
""] do puts "\e[1m#{s}\e[0m" end

#--------------------------------#
END {
  system "/bin/rm -f tmp/#{$$} tmp/#{$$}.c tmp/#{$$}.o tmp/#{$$}.asm"
}
