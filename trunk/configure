#!/usr/bin/env ruby
=begin
	GridFlow
	Copyright (c) 2001-2011 by Mathieu Bouchard

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	See file ./COPYING for further informations on licensing terms.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
=end

require "rbconfig"
CFLAGS  = ""
include Config
OSX = !!( CONFIG["arch"] =~ /darwin/ )
WIN = !!( CONFIG["arch"] =~ /(mingw|mswin)/ )
# require "win32/process" if WIN
LOG = File.open "./config.log", "w"

if WIN then # where is ANSI.SYS ?
  Red = ""
  Green = ""
  Light = ""
  Dark = ""
  Yellow = ""
  White = ""
else # use ANSI / VT100 colours
  Red   = "\e[0;1;31m"
  Green = "\e[0;1;32m"
  Light = "\e[0m"
  Dark  = "\e[0;1;30m"
  Yellow = "\e[0;1;33;44m"
  White = "\e[0;1m"
end

$verbose=false
LOG.puts "-"*64
LOG.puts "Environment Variables: "
ENV.each {|k,v| LOG.puts "#{k}=#{v}" }
LOG.puts "-"*64

puts
if not File.exist?("./configure")
	puts "Run me from the right directory please."
	exit 1
end

begin Dir.mkdir "tmp"; rescue Errno::EEXIST; end

#----------------------------------------------------------------#

class Or
	attr_reader :a
	class<< self; alias [] new end
	def initialize(*a) @a=a end
	def to_s; @a.join " or "; end
end

def launch2(log,*command)
	log << command.join(" ") << "\n"
	r,w = IO.pipe
	child = launch(nil,w,w,*command)
	w.close
	log << r.readlines.join << "\n"
	ret = join_pid(child)
	ret = ret.to_i   if RUBY_VERSION >= "1.9"
	ret = ret.to_int if RUBY_VERSION > "1.7"
	log << "error \##{ret}\n" if ret>0
	return ret<=0
end

CC = "g++"
LDSOFLAGS = []
FEATURES = {}
OPTIONS = []
DEFINES = {:CPU => nil}
OBJS = []
PDLIB = ["unicorn"]
LDSO = {}

def launch stdin,stdout,stderr,*command # -> returncode
	child = fork
	if not child then
		STDIN .reopen stdin  if stdin
		STDOUT.reopen stdout if stdout
		STDERR.reopen stderr if stderr
		exec *command
		#!@#$ what happens with exception upon exec ?
	end
	child
end

def join_pid pid; Process.waitpid2(pid)[1] end
module Future; end

class Feature
	$features = []
	def self.add(*a,&b) $features << Feature.new(*a,&b) end
	def initialize(&b) instance_eval(&b) end
	def self.attr2(sym,&b)
		eval "def #{sym}(*args,&b)
			raise args.inspect if args.length>1
			if b then @#{sym}=b.extend Future
			elsif args.length>0 then @#{sym}=args[0]
			else if Future===@#{sym} then @#{sym}.call else @#{sym} end end end"
	end
	attr2 :tag
	attr2 :name
	attr2 :produces_pdlib
	attr2 :status
	attr2 :uses_so
	attr2 :produces_o
	attr2 :uses_h
	attr2 :uses_feature
	attr2 :test
	attr2 :options
	attr2 :action
	attr2 :defines
	def find_h name
		if name[0..0]=="/" then
			File.exist?(name)
		else
			C_INCLUDE_PATH.find {|x| File.exist?(x+"/"+name)}
		end
	end
	def c_test code, link=nil, options=[], feature=nil
		link = (uses_so||[]).dup if not link
		link=link.flatten
		ldlpath = ENV["LD_LIBRARY_PATH"]
		uses_h.each {|h|
			h[0..0] == "$" or
                find_h h or
				/framework/ =~ (uses_so||[]).join(" ") or
				raise "where is #{h} ?"
		} if uses_h
		ENV["LD_LIBRARY_PATH"] = ldlpath ? "./tmp:#{ldlpath}" : "./tmp"
		link[0,0]=LDSOFLAGS.find_all {|x| String===x and /^-L/ =~ x }.flatten
		code=code.gsub(/#include#/) {
			uses_h.map {|inc| "#include <#{inc}>\n" }.join""
		}	
		log = ""
		log << code << "\n"
		binname = "tmp/#{$$}"
		sourcename = binname+".cpp"
		File.open(sourcename,"w") {|f| f.puts code }
		command = ["/usr/bin/env", CC] +
			CFLAGS.split(/ /).reject{|x| x.length==0 }
		if not launch2 log,*(command+options+[sourcename,
			 "-o", binname, *link.uniq])
			pat = Regexp.new("^"+Regexp.quote(sourcename)+":\\d+: ")
			errs = log.split("\n").find_all {|l| pat =~ l }
			raise "gcc compilation error" if not errs or
				errs.length==0
			errs = errs[0].gsub(pat,"")
			raise "gcc: #{errs}"
		end
		if not launch2 log,"tmp/#{$$}"
			raise "runtime error"
		end
		return true
	ensure
		LOG.puts log
		ENV["LD_LIBRARY_PATH"] = ldlpath if ldlpath
	end
	def asm_test code, *link
		log = ""
		log << code << "\n"
		File.open("tmp/#{$$}.asm","w") {|f| f.puts code }
		command = ["/usr/bin/env", "nasm",
		"tmp/#{$$}.asm", "-f", "elf", "-o", "tmp/#{$$}.o"]
		launch2 log,*command or return false
		command = ["#{$CC}","-o","tmp/#{$$}","tmp/#{$$}.o",*link]
		launch2 log,*command or return false
		command = ["tmp/#{$$}"]
		launch2 log,*command or return false
		true
	ensure
		LOG.puts log
	end
end

#----------------------------------------------------------------#

def read_ld_so_conf
	return [] unless File.exist?("/etc/ld.so.conf")
	x = File.open("/etc/ld.so.conf"){|f| f.read }.split("\s")
	x.delete_if { x.length==0 }
	x
end

def epath x; (ENV[x]||"").split(":") end

C_INCLUDE_PATH  = (epath("CPLUS_INCLUDE_PATH") + epath("C_INCLUDE_PATH") + ["/usr/include"]).uniq
LIBRARY_PATH    = (epath("LIBRARY_PATH")                      + ["/usr/lib","/lib"]).uniq
LD_LIBRARY_PATH = (epath("LD_LIBRARY_PATH") + read_ld_so_conf + ["/usr/lib","/lib"]).uniq
LIBX11DIR = [
  "-L/usr/X11R6/lib",  "-L/opt/gnome/lib",
  "-L/usr/X11R6/lib64","-L/opt/gnome/lib64"]
LIBX11 = LIBX11DIR + ["-lX11"]

# making it easier for everybody I hope:
def prepend_path base
	bl = base+"/lib"
	bi = base+"/include"
	if not LD_LIBRARY_PATH.include? bl and
	   not LIBRARY_PATH.include? bl then
		LDSOFLAGS.unshift "-L"+bl
		LD_LIBRARY_PATH.unshift bl
		LIBRARY_PATH.unshift bl
	end
	#and not CPLUS_INCLUDE_PATH.include? bi
	if not C_INCLUDE_PATH.include? bi then
		CFLAGS << " -I"+bi
		C_INCLUDE_PATH.unshift bi
	end
end
prepend_path "/sw" if OSX
prepend_path "/usr/local"
prepend_path ENV["HOME"]
CFLAGS << " -I."
C_INCLUDE_PATH.unshift "."

for var in [:C_INCLUDE_PATH, :LIBRARY_PATH, :LD_LIBRARY_PATH] do
	LOG.puts "#{var}: #{eval(var.to_s).inspect}"
end

LOG.puts "-"*64
CFLAGS << " -I/usr/X11R6/include"
C_INCLUDE_PATH.unshift "/usr/X11R6/include"

#----------------------------------------------------------------#
Feature.add {
	tag :gcc3; status :always_check
	name "GNU C++ Compiler 3 (or 4)"
	options ["HAVE_GCC3"]
	defines :GCC_VERSION => proc {
		begin
			/GCC_VERSION\s+(.*)/.match(File.popen("tmp/#{$$}","r"){|f| f.read })[1]
		rescue
			"3.666" # version number unknown, sorry.
		end
	}
	test proc {c_test %{
		#include <stdio.h>
		int main () {
			printf("GCC_VERSION %d.%d.%d\\n", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);
			return !(__GNUC__>=3);
		}}}}
Feature.add {
	tag :stl; status :always_check
	name "libstdc++ (GNU C++ Standard Template Library)"
	test proc {c_test %{
		#include <vector>
		int main () {std::vector<int> foo;}}}}
Feature.add {
	tag :gcc64
	name "GNU C++ in 64-bit mode"
	options ["HAVE_GCC64"]
	test proc {
		c_test %{
		#include <stdio.h>
		#include <stdlib.h>
		#include <cstddef>
		#include <sys/types.h>
		#define T(a) printf("%s:%ld; ",#a,(long)sizeof(a));
		int main () {
			T(void *)T(ptrdiff_t)T(off_t)T(size_t)puts("");
			T(char)T(short)T(int)T(long)T(long long)puts("");
			T(float)T(double)puts("");
			return !( sizeof(void*)==8 );
		}}}}
Feature.add {
	tag :pentium
	name "Pentium-compatible CPU"
	action proc { (CONFIG["arch"] =~ /i\d86/) and DEFINES[:CPU] ||= "pentium" }
	options ["HAVE_PENTIUM"]
	test proc {
		(CONFIG["arch"] =~ /(i\d86|x86_64)/) or raise "#{CONFIG["arch"]} instead"
		c_test '#define cpuid(func,ax,bx,cx,dx) \
			__asm__ __volatile__("cpuid":"=a"(ax),"=b"(bx),"=c"(cx),"=d"(dx):"a"(func))
		#include <stdio.h>
		main() {int a[4]; cpuid(0,a[0],a[1],a[2],a[3]);
		  fprintf(stderr,"cpuid: name=\"%.4s%.4s%.4s\", flags=0x%08x\n",
		  (char *)&a[1],(char *)&a[3],(char *)&a[2],a[0]); return 0;}'}}
Feature.add {
	tag :mmx
	uses_feature [:pentium]
	produces_o ["src/mmx.o","src/mmx_loader.o"]
	name "MMX-compatible CPU (using NASM)"
	options ["HAVE_MMX"]
	test proc { #!@#$ isn't 64-bit-compatible
		asm_test '
		global main
		extern exit
		align 16
		SECTION .data
		foo: dd 42,0
		SECTION .text
		main:
		lea esi,[foo]
		movq mm0,qword[esi]
		paddd mm0,qword[esi]
		movq qword [esi],mm0
		emms
		cmp dword [foo], 84
		je yes
		push long 1
		call exit
		yes:
		push long 0
		call exit
		', '-lc'}}
Feature.add {
	tag :x11
	name "X11 Display Protocol"
	uses_so LIBX11
	uses_h ["X11/Xlib.h"]
	#produces_o ["src/x11.o"]
	produces_pdlib ["x11"]
	test proc {c_test "
		#include#
		int main () {return XSetErrorHandler==0;}"}}
Feature.add {
	tag :x11_shm
	name "X11 acceleration by shared memory (XSHM plugin)"
	uses_feature [:x11]
	uses_so LIBX11+["-lXext"]
	produces_pdlib ["x11"]
	uses_h ["X11/Xlib.h","sys/shm.h","X11/extensions/XShm.h"]
	options ["HAVE_X11_SHARED_MEMORY"]
	test proc {c_test "
		#include#
		#include <X11/Xutil.h>
		#include <X11/StringDefs.h>
		#include <sys/ipc.h>
		int main () {return XShmPutImage==0;}"}}
Feature.add {
	tag :sdl
	name "Simple Directmedia Layer (experimental support)"
	uses_so {
		a=["-lSDL","-lpthread"]
		a=["-lSDL","-lpthreadGC2"] if WIN
		a=["-lSDL","-lpthread","-lobjc"] if OSX
		#a=["$$(sdl-config --libs)"] # can't really work because of exec and stuff.
		a
	}
	uses_h ["SDL/SDL.h"]
	#uses_h ["$$(sdl-config --cflags)"]
	produces_o ["src/sdl.o"]
	test proc {c_test "
		#include#
		#undef main
		int main () {return SDL_MapRGB==0;}"}}
Feature.add {
	tag :objcpp
	name "GNU/Apple ObjectiveC++ Compiler"
	uses_h ["objc/Object.h"]
	uses_so ["-lobjc"]
	test proc {c_test "
		#include#
		int main () { [[Object alloc] init]; }
		", nil, ["-xobjective-c++"]}}
Feature.add {
	tag :quartz
	name "Apple Quartz/Cocoa Display"
	uses_so ["-lobjc",["-framework","Cocoa"]]
	uses_feature [:objcpp]
	uses_h ["objc/Object.h","Cocoa/Cocoa.h"]
	produces_o ["src/quartz.o"]
	test proc {c_test "
		#include#
		int main () {return CGImageRelease==0;}
		", nil, ["-xobjective-c++"]}}
Feature.add {
	tag :aalib
	name "Ascii Art Library"
	uses_so ["-laa"]
	uses_h ["aalib.h"]
	produces_o ["src/aalib.o"]
	test proc {c_test "
		#define aa_hardwareparams aa_hardware_params
		extern \"C\" {
		#include#
		};
		int main () {return aa_init==0;}"}}
Feature.add {
	tag :jpeg
	name "JPEG Library"
	uses_so ["-ljpeg"]
	uses_h ["jpeglib.h"]
	produces_o ["src/jpeg.o"]
	test proc {c_test "
		extern \"C\" {
		#include <stdio.h>
		#include#
		};
		int main () {
		return jpeg_write_scanlines==0;}"}}
Feature.add {
	tag :png
	name "PNG Library"
	uses_so ["-lpng","-lz"]
	uses_h Or[["png.h"],["libpng/png.h"],["libpng14/png.h"],["libpng12/png.h"]]
	produces_o ["src/png.o"]
	test proc {|f| f.c_test %`
		extern "C" {
		#include <stdio.h>
		#include#
		};
		int main () {
		#define T(a) printf("%s:%ld; ",#a,long(sizeof(a)));
		T(png_uint_32)T(long)puts("");
		if (!png_sig_cmp) return 1;
		return 0;}`}}
Feature.add {
	tag :videodev
	name "Video4linux Driver Interface Version 1 (kernel)"
	uses_h ["linux/videodev.h"]
	produces_o ["src/videodev.o"]
	test proc {c_test "
		#include <stdlib.h>
		#include#
		int main () { struct video_window foo; return 0; }"}}
Feature.add {
	tag :libv4l1
	uses_feature [:videodev]
	name "Video4linux I Driver Interface Library"
	uses_h ["libv4l1.h"]
	uses_so ["-lv4l1"]
	options ["HAVE_LIBV4L1"]
	test proc {c_test "
		#include <linux/videodev.h>
		#include <sys/types.h>
		#include <libv4l1.h>
		int main () {return v4l1_open==0;}"}}
Feature.add {
	tag :libv4l2
	name "Video4linux II Driver Interface Library"
	uses_h ["libv4l2.h"]
	uses_so ["-lv4l2"]
	produces_o ["src/v4l2.o"]
	test proc {c_test "
		#include <libv4l2.h>
		int main () {return v4l2_open==0;}"}}
Feature.add {
	tag :dc1394
	name "DC1394 for Linux"
	uses_so ["-ldc1394_control"]
	uses_h Or["libdc1394/dc1394_control.h","dc1394/control.h"]
	produces_o ["src/dc1394.o"]
	options ["HAVE_DC1394"]
	test proc {|f| f.c_test "
		#include#
		int main () {return dc1394_create_handle==0;}"}}
Feature.add {
	tag :mpeg3
	name "HeroineWarrior LibMPEG3"
	uses_so LIBX11DIR+["-lmpeg3","-lpthread","-lm"]
	uses_h Or["libmpeg3/libmpeg3.h","libmpeg3.h"]
	produces_o ["src/mpeg3.o"]
	test proc {|f| f.c_test "
		#include#
		int main () { return mpeg3_open==0; }"}}
Feature.add {
	tag :quicktimeapple
	name "Apple's QuickTime"
	uses_so [["-framework","Quicktime"]]
	uses_h ["QuickTime/QuickTime.h","QuickTime/Movies.h"]
	produces_o ["src/quicktimeapple.o","src/quicktimecamera.o"]
	test proc {c_test "
		#include#
		int main () { return EnterMovies==0; }
		"}}
Feature.add {
	tag :quicktimehw
	name "Plaum's LibQuickTime"
	uses_so Or[
		LIBX11DIR+["-lquicktime","-lpthread","-lpng","-ldl","-lglib"    ,"-lz"],
		LIBX11DIR+["-lquicktime","-lpthread","-lpng","-ldl","-lglib-1.2","-lz"],
		LIBX11DIR+["-lquicktime","-lpthread","-lpng","-ldl","-lglib-2.0","-lz"]]
	f = ["quicktime.h","colormodels.h","lqt.h","lqt_version.h","lqt_codecinfo.h"]
	uses_h Or[
		f.map{|x| "lqt/"+x },
		f.map{|x| "quicktime/"+x }]
	produces_o ["src/quicktimehw.o"]
	test proc {|f| f.c_test %`
		#include <stdio.h>
		#include#
		int main () {
		fprintf(stderr,"LQT_VERSION = %s\\n",
		#ifdef LQT_VERSION
			LQT_VERSION
		#else
			"(undefined)"
		#endif
		); return quicktime_open==0; }
		`}}
Feature.add {
	tag :opencv
	name "Intel OpenCV"
	produces_o ["src/opencv.o"]
	uses_so ["-lcv"]
        uses_so ["-L/Users/pddev/lib","-lcv"] if OSX # for the build system used in 9.13
       #uses_so ["-F/Users/pddev/Frameworks -framework OpenCV"] if OSX
	options ["HAVE_OPENCV"]
	defines {{:OPENCV_SHARE_PATH => File.dirname(C_INCLUDE_PATH.find {|x| File.exist?(x+"/opencv/cv.h")}) + "/share/opencv"}}
	test proc {c_test %`
			#include <opencv/cv.h>
			int main () {return 0;}`}}
Feature.add {
	tag :fftw
	name "FFTW (Fastest Fourier Transform in the West)"
	produces_o ["src/fftw.o"]
	uses_so Or[["-lfftw3f","-lfftw3"],["-lfftw3f-3","-lfftw3-3"]]
	options ["HAVE_FFTW"]
	test proc {|f| f.c_test %`
		#include <fftw3.h>
		int main () {return 0;}`}}
Feature.add {
	tag :opengl
	name "OpenGL/GLEW (for GEM support and [gf/gl])"
	produces_o ["src/opengl.o"]
        uses_so LIBX11DIR+["-lGLEW"] if not WIN
	uses_so ["-lglu32","-lopengl32","-lglew32"] if WIN
        uses_h ["GL/glew.h"]
	options ["HAVE_OPENGL"]
	test proc {c_test %`
                #include#
                int main () {return (GLint)0;}
                `
        }
}
Feature.add {
	tag :gem
	name "GEM support (loadtime detect: don't disable)"
	produces_pdlib ["gem_loader","gem9292","gem9293","gem9393"]
	uses_feature [:opengl]
        uses_so LIBX11DIR+["-lGLEW"] if not WIN
	uses_so ["-lglu32","-lopengl32","-lglew32"] if WIN
}
Feature.add {
	tag :pdp
	name "PDP support (loadtime detect: don't disable)"
	produces_pdlib ["pdp"]
}
Feature.add {
	tag :android
	name "Android module"
	produces_o ["src/android.o"]
    test proc {raise "use --force-android if you want this"}
}

#--------------------------------#

$features_h = {}
$features.each {|f| $features_h[f.tag]=f }

def usage
	log = ""
	log << "usage: ./configure "
	log << "[--use-compiler compiler] [--use-compiler-option option]* "
	log << "[--use-cpu cpu] [--lite] [--debug] [--explicit]"
	$features_h.keys.map {|k| k.to_s }.sort.each {|k| log << "[--no-#{k}] " }
	$features_h.keys.map {|k| k.to_s }.sort.each {|k| log << "[--force-#{k}] " }
	puts
	while log.length>0 do puts log.slice!(/^.{1,70} /) end
end

$debug=false
$explicit=false
while ARGV.length>0 do
	arg=ARGV.shift
	case arg
	when /=/
		i=arg.index '='
		ARGV.unshift arg[0..i-1], arg[i+1..-1]
	when /^--no-/
		name = arg[5..-1].untaint.intern
		if $features_h[name] then 
			puts "--no: won't check for feature #{name}"
			$features_h[name].status :disabled_by_user
		else
			puts "there is no feature called #{name}"
		end
	when "--explicit"
		$explicit=true
	when /^--force-/
		name = arg[8..-1].untaint.intern
		if $features_h[name] then 
			puts "--force: assuming #{name} is there"
			$features_h[name].test nil
		else
			puts "there is no feature called #{name}"
		end
	when "--debug"
		puts "Debug Mode (more error checking; less speed)"
		$debug=true
		OPTIONS.push :HAVE_DEBUG
	when "--lite"
		puts "Lite Mode (no float64, no int64)"
		OPTIONS.push :HAVE_LITE
	when "--help"
		usage; exit 0
	when "--use-compiler"
		CC = ARGV.shift
	when "--use-compiler-option"
		CFLAGS << " "+ARGV.shift
	when "--use-cpu"
		DEFINES[:CPU] = ARGV.shift
	when "--verbose"
		$verbose=true
	else puts "unknown option \"#{arg}\""; usage; exit 1
	end
end

if $debug
	CFLAGS << " -O0 -fno-inline"
else
	CFLAGS << " -O3"
end

#--------------------------------#

DUAL = Object.new
DUAL.instance_eval {
	def self.print x
		LOG   .puts  x; LOG   .flush
		STDERR.print x; STDERR.flush
	end
	def self.puts(x) self.print x+"\n" end
}

def try feature
	if Proc===feature.uses_so then feature.uses_so(feature.uses_so[]) end
	if Or===feature.uses_so
		k=1; feature.uses_so.a.each {|i|
			e=feature.dup; e.uses_so i; e.name(e.name+" (try \##{k})")
			r=try e; k+=1; return r if r }
		return false
	end
	if Proc===feature.uses_h then feature.uses_h(feature.uses_h[]) end
	if Or===feature.uses_h
		k=1; feature.uses_h.a.each {|i|
			i=[i] if String===i
			e=feature.dup; e.uses_h i; e.name(e.name+" <#{i[0]}>")
			r=try e; k+=1; return r if r }
		return false
	end
	LOG.puts "", "-"*64
	line = "[#{feature.tag}] #{feature.name}: "
	DUAL.print Light + "[#{Yellow}#{feature.tag}#{Light}] #{feature.name}: "
	arrow = "-"*([78-line.length,0].max)+ "> "
	#DUAL.print Dark + arrow +Red
	(feature.uses_feature||[]).find {|f|
		if not (
		  if Or===f then f.a.find {|x| FEATURES[x] } else FEATURES[f] end
		) then 
			DUAL.puts Red+arrow+"disabled (would need #{f})"
			return
		end
	}
	if feature.status==:disabled then DUAL.puts Dark+arrow+"disabled (by author)"; return end
	if feature.status==:disabled_by_user or ($explicit and feature.test and not feature.status==:always_check) then DUAL.puts Dark+arrow+"disabled (by user)"; return end
	fu = [fu] if not Array===fu
	for f in fu || [] do
		if FEATURES[f] then DUAL.puts Dark+arrow+"disabled (using #{f} instead)"; return end
	end
	if feature.test
		begin tresult = feature.test.call(feature); rescue StandardError => e; end
		if tresult
			DUAL.puts Green+arrow+"found "+(if tresult!=true then " (#{tresult})" else "" end)
		else
			DUAL.puts Red+arrow+"missing "+(if e
				then (if $verbose
					then "(#{e} @ #{e.backtrace.join', '})"
					else "(#{e})" end)
				else "(return false)" end)
			if e
				LOG.puts e.inspect
				LOG.puts e.backtrace
			end
			return false
		end
	else
		puts Green+arrow+"enabled"
		FEATURES[feature.tag] = feature
		feature.action.call if feature.action
	end
	feature.action.call if feature.action
	FEATURES[feature.tag] = feature
	category = "main"
	category = feature.produces_pdlib[0] if feature.produces_pdlib
	(LDSO[category]||=[]).concat(feature.uses_so||[]).uniq!
	OPTIONS.concat(feature.options||[])
	OBJS.concat(feature.produces_o    ||[])
	PDLIB.concat(feature.produces_pdlib||[]).uniq!
	for k,v in feature.defines||{} do DEFINES[k]=(if Proc===v then v[] else v end) end
	true
end

DUAL.puts "This is the GridFlow 9.14 configurator"

begin
  $features.each {|feature| try feature }
ensure
  #!@#$ note: see END{} (duplication)
  system "/bin/rm -f tmp/#{$$} tmp/#{$$}.c tmp/#{$$}.o tmp/#{$$}.asm"
end

puts Light

LDSOFLAGS.uniq!

$exit=false
def need s
  if not FEATURES[s] then puts "#{Red}You need to install #{$features_h[s].name}#{Light}"; $exit=true end
end
need :gcc3
need :stl
(puts; exit 1) if $exit

#--------------------------------#

LOG.puts "-"*64
LOG.puts        "$CC: #{CC.inspect}"
LOG.puts "$LDSOFLAGS: #{LDSOFLAGS.inspect}"
LOG.puts   "$OPTIONS: #{OPTIONS.inspect}"
LOG.puts   "$DEFINES: #{DEFINES.inspect}"
LOG.puts      "$OBJS: #{OBJS.inspect}"
LOG.puts     "$PDLIB: #{PDLIB.inspect}"
for k in LDSO.keys.sort do
  LOG.puts "$LDSO[#{k.inspect}]: #{LDSO[k].inspect}"
end
LOG.puts "-"*64
RUBY = "$(RUBY_INSTALL_NAME)"

puts "generating ./config.make"
File.open("./config.make","w") {|f|
  CFLAGS <<  " -mcpu=$(CPU)" if DEFINES[:CPU] and DEFINES[:GCC_VERSION] <  "4"
  CFLAGS << " -mtune=$(CPU)" if DEFINES[:CPU] and DEFINES[:GCC_VERSION] >= "4"
  CFLAGS << " -march=$(CPU)" if DEFINES[:CPU]
  CFLAGS << " -DMACOSX" if OSX
  f.puts "CFLAGS += " + CFLAGS
  f.puts "LDSOFLAGS += " + LDSOFLAGS.flatten.join(" ")
  for k   in OPTIONS do f.puts "#{k}=yes" end
  for k,v in DEFINES do f.puts "#{k}=#{v}" end
  f.puts "CXX = #{CC}"
  f.puts "OBJS = #{OBJS.join(" ")}"
  f.puts "DLEXT = #{CONFIG['DLEXT']}"
  f.puts ""
  f.puts "PDLIB = gridflow$(PDSUF) "+PDLIB.map{|x|"gridflow_#{x}$(PDSUF)"}.join(" ")
  for k in LDSO.keys.sort do
    f.puts "LDSO_#{k} = "+LDSO[k].join(" ") if LDSO[k]
  end
} # end open config.make

#--------------------------------#
puts "generating config.h"
File.open("config.h","w") {|f|
f.puts "
\#ifndef __CONFIG_H
\#define __CONFIG_H
/* this file was auto-generated by gridflow/configure */"
f.puts "#define STARTUP_LIST(PRE) \\"
f.puts OBJS.map {|o|
	oo = File.basename(o,'.o').split(/-/)[0]
	oo.gsub!(/\$\(PDSUF\)$/,"")
	"PRE startup_#{oo}();"
}.join("\\\n")
for k   in OPTIONS do f.puts "\#define #{k}" end
for k,v in DEFINES do f.puts "\#define #{k} "+v.inspect end

def include_here(f,a,b,c=false)
  return unless FEATURES[b]
  f.puts "\#ifdef #{a}_INCLUDE_HERE"
  f.puts "extern \"C\" {"
  for inc in FEATURES[b].uses_h.to_a do
    f.puts "\#include <#{inc}>"
  end
  f.puts "};"
  f.puts "\#endif"
end
include_here f,"DC1394", :dc1394
include_here f,"LIBMPEG", :mpeg3
include_here f,"QUICKTIMEHW",:quicktimehw
include_here f,"PNG",:png

f.puts "
\#endif /* __CONFIG_H */"
} # end open config.h

#--------------------------------#
puts %{#{White}\
See ./config.log if you want the details of the configuration tests.
"If you are satisfied with that configuration, you may go on, and do "make".
there is no "make install". just move your gridflow directory to
"lib/pd/extra", and make sure that it's named "gridflow". Or else add a -path
option towards the folder which contains the folder named "gridflow" (and not
to the folder named "gridflow" itself). If you get stuck, ask gridflow-dev.
#{Light}}

#--------------------------------#
END {
  system "/bin/rm -f tmp/#{$$} tmp/#{$$}.c tmp/#{$$}.o tmp/#{$$}.asm"
}
