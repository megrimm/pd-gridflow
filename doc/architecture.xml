<?xml version="1.0" standalone="no" ?>
<!DOCTYPE jmax-doc SYSTEM 'jmax.dtd'>
<jmax-doc>
<!-- $Id$ -->
<!--
	GridFlow Reference Manual: Architecture
	Copyright (c) 2001,2002 by Mathieu Bouchard and Alexandre Castonguay
-->

<!--
<section name="Conventions of this Manual">
<prose>
	(In this section, usage of Bold, Italic, Courier, etc. would be explained.
	eventually I'd like those to have precise meanings consistent throughout
	the whole documentation)
</prose>
</section>
-->

<section name="Numbers"><prose>

	<p>High-performance computation requires precise and quite peculiar
	definitions of numbers and their representation.</p>

	<p>Inside most programs, numbers are written down as strings of
	bits. A bit is either zero or one. Just like the decimal system
	uses units, tens, hundreds, the binary system uses units, twos,
	fours, eights, sixteens, and so on.</p>

	<p>One notation called integer allows for only integer values to be
	written (no fractions). when it is unsigned, no negative values may
	be written. when it is signed, one bit indicates whether the number
	is positive or negative.</p>

	<p>In GridFlow, there are two kinds of numbers:</p>

	<p><b>int32</b>, signed 32-bit integer.
	values from -2147483648 to 2147483647
	(which is from -2<sup>31</sup> to 2<sup>31</sup>-1).
	this is used for most computations.
	</p>
	
	<p><b>uint8</b>, unsigned 8-bit integer.
	values from 0 to 255
	(which is from 0 to 255).
	this is the usual size of numbers taken from files and cameras, and
	written to files and to windows.
	</p>

</prose></section>

<section name="Grid Literals"><prose>
<p>
	In every grid-accepting inlet, a list may be sent instead; if
	it consists only of integers, it will be converted to a
	one-dimensional grid. Else it may contain a single "#" sign and
	integers on both sides of it, where the ones to the left of it are
	fed as arguments to an imaginary [@redim] object and the one to the
	right of it are fed through that [@redim].
</p>
<p>
	In every grid-accepting inlet, an integer or float may also be sent;
	it will be converted to a zero-dimensional grid (a <b>scalar</b>).
</p>
</prose></section>

<section name="Grid Protocol"><prose>
	<p>
	each element of a grid is an <b>int32</b>.
	</p>
	<p>
	a single-dimensional grid of 3 elements (a triplet) is called dim(3). a
	three-dimensional grid of 240 rows of 320 columns of triplets is called
	dim(240,320,3).
	</p>
	<p>
	There is a sequence in which elements of a Grid are stored and
	transmitted.  Dimension 0 is called "first" and dimension N-1 is
	called "last". They are called so because if you select a
	position in the first dimension of a grid, the selected part is of the same
	shape minus the first dimension; so in dim(240,320,3) if you select
	row 51 (or whichever valid row number), you get a dim(320,3). if you select
	a subpart two more times you get to a single number.
	</p>
	<p>
	At each such level, elements are sent/stored in their numeric order, 
	and are numbered using natural numbers starting at 0. This ordering usually 
	does not matter, but sometimes it does. Most notably, <k>@import</k>, 
	<k>@export</k> and <k>@redim</k> care about it. 
	</p>
	<p>
	On the other hand, order of dimensions usually does matter; this is 
	what distinguishes rows from columns and channels, for example.
	Most objects care about the distinction.
	</p>
	<p>
	A grid with only 1 element in a given dimension is different from one
	lacking that dimension; it won't have the same meaning. You can use this
	property to your advantage sometimes.
	</p>
	<p>
	Zero-dimensional grids exist. They are called dim(). They can only contain
	a single number.
	</p>
</prose></section>

<section name="Picture Protocol"><prose>
	<p><i>This section is useful if you want to know what a picture is
	in terms of a grid.
	</i></p>

	<p>A picture is a three-dimensional Grid: 
	<list start="0">
		<li>rows</li>
		<li>columns</li>
		<li>channels</li>
	</list>
	</p>
	<p>Channels for the RGB color model are:
	<list start="0">
		<li>red</li>
		<li>green</li>
		<li>blue</li>
	</list>
	</p>
	<p>
	Because Grids are made of 32-bit integers, a three-channel picture uses 
	96 bpp (bits per pixel), and have to be downscaled to 24 bpp (or 16 bpp) 
	for display. That huge amount of slack is there because when you create 
	your own effects you often have intermediate results that need to be of 
	higher precision than a normal picture. Especially, results of multiplications 
	are big and should not overflow before you divide them back to normal; 
	and similarly, you can have negative values all over, as long as you take 
	care of them before they get to the display.
	</p>
	<p>
	In the final conversion, high bits are just ignored. This means: black is
	0, maximum is 255, and values wrap like with <k>% 256</k>. If you want to
	clip them, you may use <k>"@ max 0"</k> and <k>"@ min 255"</k> objects. 
	</p>
</prose></section>

<section name="One-Input Operators">

	<!-- todo: text attr in those icons could be auto-generated -->

	<operator-1 name="abs" cname="abs"
	> absolute value of A </operator-1>
	<operator-1 name="rand" cname="rand"
	> randomly produces a non-negative number below A </operator-1>
	<operator-1 name="sqrt" cname="sqrt"
	> square root of A, rounded downwards </operator-1>
	<operator-1 name="sq" cname="sq"
	> A times A </operator-1>
</section>

<section name="Two-Input Operators">
	<prose>
		<p>In the following table, A is the value entered to the
		left, and B is the value entered to the right.</p>

		<p>Angles are in hundredths of degrees. This means a full circle
		(two pi radians) is 36000. You convert from degrees to our angles
		by multiplying by 100. You convert from radians to our angles by
		multiplying by 18000/pi.</p>

		<p>Hyperbolic functions (tanh) work with our angles too, so the
		same conversions apply.</p>
	</prose>

	<!-- todo: text attr in those icons could be auto-generated -->
	<!-- todo: make CNAME a column in html -->

	<!-- category: bogus -->
	<operator-2 name="ignore" cname="ignore"
		color="no effect"
		space="no effect"
	> A </operator-2>
	<operator-2 name="put"    cname="put"
		color="replace by"
		space="replace by"
	> B </operator-2>

	<!-- category: additive -->
	<operator-2 name="+"    cname="add"
		color="brightness, crossfade"
		space="move, morph"
	> A + B </operator-2>
	<operator-2 name="-"    cname="sub"
		color="brightness, motion detection"
		space="move, motion detection"
	> A - B </operator-2>
	<operator-2 name="inv+" cname="bus"
		color="negate then contrast"
		space="180 degree rotate then move"
	> B - A </operator-2>

	<!-- category: multiplicative -->
	<operator-2 name="*"     cname="mul"
		color="contrast"
		space="zoom out"
	> A * B </operator-2>
	<operator-2 name="/"     cname="div"
		color="contrast"
		space="zoom in"
	> A / B, rounded towards zero </operator-2>
	<operator-2 name="div"   cname="div2"
		color="contrast"
		space="zoom in"
	> A / B, rounded downwards </operator-2>
	<operator-2 name="inv*"  cname="vid"
	> B / A, rounded towards zero </operator-2>
	<operator-2 name="swapdiv" cname="vid2"
	> B / A, rounded downwards </operator-2>
	<operator-2 name="%"     cname="mod"
		space="tile"
	> A % B, modulo (goes with div) </operator-2>
	<operator-2 name="swap%" cname="dom"
	> B % A, modulo (goes with div) </operator-2>
	<operator-2 name="rem"     cname="rem"
	> A % B, remainder (goes with /) </operator-2>
	<operator-2 name="swaprem" cname="mer"
	> B % A, remainder (goes with /) </operator-2>

	<!-- bits -->
	<operator-2 name="|"     cname="or" 
		color="bright munchies"
		space="bottomright munchies"
	> A or B, bitwise  </operator-2>
	<operator-2 name="^"     cname="xor"
		color="symmetric munchies (fractal checkers)"
		space="symmetric munchies (fractal checkers)"
	> A xor B, bitwise </operator-2>
	<operator-2 name="&amp;" cname="and"
		color="dark munchies"
		space="topleft munchies"
	> A and B, bitwise </operator-2>
	<operator-2 name="&lt;&lt;" cname="shl"
		color="like *"
		space="like *"
	> A * (2**(B % 32)), which is left-shifting </operator-2>
	<operator-2 name="&gt;&gt;" cname="shr"
		color="like /,div"
		space="like /,div"
	> A / (2**(B % 32)), which is right-shifting </operator-2>

	<!-- decision -->
	<operator-2 name="||" cname="sc_or"
	> if A is zero then B else A </operator-2>
	<operator-2 name="&amp;&amp;" cname="sc_and"
	> if A is zero then zero else B</operator-2>
	<operator-2 name="min" cname="min"
		color="clipping"
		space="clipping (of individual points)"
	> the lowest value in A,B </operator-2>
	<operator-2 name="max" cname="max"
		color="clipping"
		space="clipping (of individual points)"
	> the highest value in A,B </operator-2>

	<!-- comparison -->
	<operator-2 name="cmp"   cname="cmp"
	> -1 when A&lt;B; 0 when A=B; 1 when A&gt;B. </operator-2>
	<operator-2 name="=="    cname="eq"
	> is A equal to B ? 1=true, 0=false </operator-2>
	<operator-2 name="!="    cname="ne"
	> is A not equal to B ? </operator-2>
	<operator-2 name="&gt;"  cname="gt"
	> is A greater than B ? </operator-2>
	<operator-2 name="&lt;=" cname="le"
	> is A not greater than B ? </operator-2>
	<operator-2 name="&lt;"  cname="lt"
	> is A less than B ? </operator-2>
	<operator-2 name="&gt;=" cname="ge"
	>is A not less than B ? </operator-2>

	<!-- trigonometrics and exponentiation -->
	<operator-2 name="sin*" cname="sin"
		space="waves, rotations"
	> B * sin(A) </operator-2>
	<operator-2 name="cos*" cname="cos"
		space="waves, rotations"
	> B * cos(A) </operator-2>
	<operator-2 name="atan" cname="atan"
		space="find angle to origin (part of polar transform)"
	> arctan(A/B) </operator-2>
	<operator-2 name="tanh*" cname="tanh*"
		color="smooth clipping"
		space="smooth clipping (of individual points), neural sigmoid"
	> B * tanh(A) </operator-2>
	<operator-2 name="log*" cname="log*"
	> B * log(A) (in base e) </operator-2>
	<operator-2 name="gamma" cname="gamma"
		color="gamma correction"
	> floor(pow(a/256.0,256.0/b)*256.0) </operator-2>
	<operator-2 name="**" cname="pow"
		color="gamma correction"
	> A**B, that is, A raised to power B </operator-2>
</section>

<section name="Bridges"><prose>
<p>Starting with version 0.6, GridFlow is Ruby-centric instead of jMax-centric.
jMax support has been added back as a <b>Bridge</b>.</p>

<p>Bridges, for the most part, plug into the FObject class, which is the common
root of most of GridFlow's classes. Under the current design, the bridge is
compiled separately, and is directly loaded by the host software; then the
bridge starts Ruby and makes it load the main GridFlow; then the bridge hooks
with the main part.
</p>

</prose></section>

</jmax-doc>
