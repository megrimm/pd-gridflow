	<class name="#spread">
		typically you plug a [#for] into this object,
		and you plug this object into the left side of a [#store]. it will
		scatter pixels around, giving an "unpolished glass" effect.
		
		if you put a picture in it, however, it will add noise. The
		resulting values may be out of range, so you may need to clip them
		using min/max.

		<method name="init">
			<arg name="factor">same as inlet 1</arg>
		</method>

		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a coordinate map.</method>
		</inlet>
		<inlet id="1">
			<method name="int">a spread factor.</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a coordinate map.</method>
		</outlet>


		[#spread] scatters the pixels in an image. Not all original pixels
		will  appear, and some may get duplicated (triplicated, etc)
		randomly. Some  wrap-around effect will occur close to the edges.
		

		 Sending an integer to inlet 1 sets the amount of spreading in
		maximum  number of pixels + 1. even values translate the whole image
		by half  a pixel due to rounding.

	</class>

	<class name="#rotate">
		performs rotations on indexmaps and polygons and such.
		
		<method name="init">
			<arg name="angle" type="0...35999"/>
		</method>
		<inlet id="0"><method name="grid">
			<arg name="grid" type="grid(anyA 2)"/></method></inlet>
		<inlet id="1"><method name="int">rotation angle; 0...36000</method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(anyA 2)"/>
		</method></outlet>
	</class>

	<class name="#remap_image">
		if you chain indexmap (coordinate) transformations from outlet 1
		to inlet 1, then sending an image in inlet 0 will emit its
		deformation out of outlet 0.

		<inlet id="0"/>
		<inlet id="1"/>
		<outlet id="0"/>
		<outlet id="1"/>
	</class>
	<class name="#dim">
		Returns list of dimensions as a grid. Given a grid sized like Dim(240,320,4), 
		[#dim] will return a grid like Dim(3), whose values are 240, 320, 4. 

		<method name="init">
			no arguments.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
				ignores any data contained within.
				sends a grid dim(length of dims) containing dims.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid(rank)"/>
				the list of dimensions of the incoming grid.
			</method>
		</outlet>
	</class>

	<class name="#type">
		gives a symbol representing the numeric type of the grid received.
		
		<outlet id="0"><method name="&lt;numeric type symbol&gt;"/></outlet>
	</class>

	<class name="display">
		GUI object equivalent to [print] and [#print].
		<method name="(any)">
		Displays the received message in the box, resizing the box so that the message fits exactly.
		</method>
	</class>
	<class name="#apply_colormap_channelwise">
		This object is useful for color correction. For each pixel
		it takes it apart, looks up each part separately in the colormap,
		and constructs a new pixel from that. You may also color-correct
		colormaps themselves.

		Only works for things that have 3 channels.

		Note: if you just need to apply a palette on an indexed-color
		picture, you don't need this. Just use #store instead.
		
		<inlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns channels)"/>
			picture
		</method></inlet>
		<inlet id="1">
			<method name="grid">
			<arg name="grid" type="grid(intensities channels)"/>
			colormap ("palette")
		</method></inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns channels)"/>
			picture
		</method></outlet>
	</class>

	<class name="#rgb_to_greyscale">
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {red green blue})"/>
		</method></inlet>
		<outlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {white})"/></method>
		</outlet>
	</class>

	<class name="#greyscale_to_rgb">
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {white})"/></method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns {red green blue})"/>
		</method></outlet>
	</class>

	<class name="#yuv_to_rgb">
		note: may change slightly to adapt to actual video standards.
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {y u v})"/></method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns {red green blue})"/>
		</method></outlet>
	</class>

	<class name="#rgb_to_yuv">
		note: may change slightly to adapt to actual video standards.
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {red green blue})"/></method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns {y u v})"/>
		</method></outlet>
	</class>
	<class name="#convolve">
		this is the object for blurring, sharpening, finding edges,
		embossing, cellular automata, and many other uses.
<!--NYI
		<attr name="seed">
		
		</attr>
-->
		<method name="init">
			<arg name="op_para" type="numop2"/>
			<arg name="op_fold" type="numop2"/>
			<arg name="seed"   type="grid"/>
			<arg name="right_hand" type="grid" default="none"/>
		</method>
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns rest...)"/>
				splits the incoming grid into dim(rest...) parts.
				for each of those parts at (y,x), a rectangle of such
				parts, centered around (y,x), is combined with the
				convolution grid like a [#] of operation op_para. Then
				each such result is folded like [#fold] of operation
				op_fold and specified base. the results are assembled
				into a grid that is sent to the outlet. near the borders of
				the grid, coordinates wrap around. this means the whole grid
				has to be received before production of the next grid
				starts.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid">
				<arg name="grid" type="grid(rows2 columns2)"/>
				this is the convolution grid and it gets stored in
				the object. if rows2 and/or columns2 are odd numbers,
				then the centre of convolution is the middle of the convolution
				grid. if they are even numbers, then the chosen centre will
				be slightly more to the left and/or to the top, because the
				actual middle is between cells of the grid.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns rest...)"/>
			</method>
		</outlet>
	</class>

	<class name="#contrast">
		<method name="init">
			<arg name="iwhiteness" default="256">same as inlet 1.</arg>
			<arg name="contrast" default="256">same as inlet 2.</arg>
		</method>

		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/>
			produces a grid like the incoming grid but with
			different constrast.
			</method>
			[#contrast] adjusts the intensity in an image.
			resulting values outside 0-255 are automatically clipped.
		</inlet>
		<inlet id="1">
			<method name="int">
			this is the secondary contrast (inverse whiteness).
			it makes the incoming black
			correspond to a certain fraction between output black and the
			master contrast value. no effect is 256. default value is 256.
			</method>	
		</inlet>
		<inlet id="2">
			<method name="int">
			this is the master contrast. it makes the incoming white
			correspond to a certain fraction between output black and output
			white. no effect is 256. default value is 256.
			</method>	
		</inlet>
		<outlet>
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/>
			</method>
		</outlet>
	</class>

	<class name="#posterize">
		[#posterize] reduces the number of possible intensities in an image;
		it rounds the color values.The effect is mostly apparent with a low
		number of levels.

		<method name="init">
			<arg name="levels">same as inlet 1</arg>
		</method>

		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/>
				produces a posterized picture from the input picture.
			</method>
		</inlet>

		<inlet id="1">
			<method name="int">
				this is the number of possible levels per channel. the
				levels are equally spaced, with the lowest at 0 and the
				highest at 255. the minimum number of levels is 2, and the
				default value is 2.
			</method>
		</inlet>
		
		<outlet id="0">
		</outlet>

		example: simulate the 216-color "web" palette using 6 levels.
		simulate a 15-bit display using 32 levels.
	</class>

	<class name="#solarize">
		makes medium intensities brightest; formerly brightest colours
		become darkest; formerly darkest stays darkest. This filter is linear:
		it's like a 200% contrast except that overflows are <i>mirrored</i>
		instead of clipped or wrapped.
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/></method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/></method>
		</outlet>
	</class>

	<class name="#checkers">
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {y x})"/>
				result from a [#for {0 0} {height width} {1 1}]
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				checkered pattern of 50%/75% greys
				in 8x8 squares
			</method>
		</outlet>
	</class>

	<class name="#layer">
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b a})"/>
				a picture that has an opacity channel.
				will be used as foreground.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				a picture that has NO opacity channel.
				will be used as background.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				a picture that has NO opacity channel.
				the opacity channel of the foreground is used as
				a weighting of how much of either picture is seen
				in the result.
			</method>
		</outlet>
	</class>

	<class name="#text_to_image">
		inlet 2 receives a font grid, for example, [#in grid file lucida-typewriter-12.grid.gz]
		inlet 1 receives a 2 by 3 matrix representing the colours to use (e.g. (2 3 # 0 170 0 255 255 0) means yellow on green)
		inlet 0 receives a bang, transforming the data into an image suitable for #draw_image.
	</class>
	<class name="#hueshift">
		inlet 1 receives an angle (0..36000)
		inlet 0 receives a RGB picture that gets hueshifted by a rotation in the colorwheel by the specified angle; it gets sent to outlet 0.
	</class>
	<class name="pingpong">
		Transforms linear counting (0, 1, 2, 3, 4, ...)  into a back-and-forth counting (0, 1, 2, 1, 0, ...)
		from 0 to a specified upper bound.
		<method name="init">
			<arg name="top" type="int"/>
		</method>
		<inlet id="1">
			<method name="float"><arg name="top" type="float"/></method>
		</inlet>
		<inlet id="0">
			<method name="float">
				a value to be transformed.
				If, for example, top=10, then values 0 thru 10 are left unchanged,
				values 11 thru 19 are mapped to 9 thru 1 respectively, and 20 thru 30
				are mapped to 0 thru 10, and so on.
			</method>
		</inlet>
	</class>
	<class name="fps">
		<method name="init">
			<arg name="clocktype" type="symbol(real|user|system|cpu)">
				which clock to use. "real" uses wallclock time. "user" uses
				the amount of time spent in the process. "system" uses the
				amount of time spent in the kernel on behalf of the process.
				"cpu" uses the Pentium clock, which is like a more precise
				version of "real" if you have a Pentium.
			</arg>
			<arg name="detailed" type="symbol(detailed)">optional</arg>
		</method>
		<method name="init detailed">
		</method>
		<inlet id="0">
			<method name="bang">
			Times at which bangs are received are stored until a large
			enough sample of those is accumulated. Large enough is defined
			to be whenever the timespan exceeds one second. Then a report
			is made through the outlet.
			</method>
			<method name="(else)">
				messages other than bangs are ignored.
			</method>
		</inlet>
		<outlet id="0">
			<method name="float">
			non-detailed mode only.
			this is the messages-per-second rating.
			</method>
			<method name="list(float,6)">
			detailed mode only.
			this is: messages-per-second, followed by five values of
			milliseconds-per-message: minimum, median, maximum, average,
			standard deviation.
			(the average happens to be simply 1000 divided by the
			messages-per-second, but it is convenient to have it anyway)
			</method>
		</outlet>
	</class>
	<class name="fork">
		Every incoming message is sent to inlet 1 and then sent to
		inlet 0 as well. Messages remain completely unaltered. Contrast
		with PureData's "t a a" objects, which have the same purpose but
		transform bangs into zeros and such.

		<inlet id="0"><method name="(any)"/></inlet>
		<outlet id="0"/>
		<outlet id="1"/>
	</class>
	<class name="foreach">
		<inlet id="0"><method name="list"><rest/>
			Outputs N messages, one per list element, in order.
		</method></inlet>
	</class>
	<class name="listreverse">
		<inlet id="0"><method name="list"><rest/>
			Outputs the incoming list, from last element to first element.
		</method></inlet>
	</class>
	<class name="range">
		<method name="init">
			<rest name="separators" type="float"></rest>
		</method>
		<inlet id="0"><method name="float">
			a value to be sent to one of the outlets. The first outlet is for values
			smaller than the first argument; else the second outlet is for values smaller
			than the second argument; and so on; and the last outlet is for values greater
			or equal to the last argument.
		</method></inlet>
		<inlet id="1..n"><method name="float">
			sets the corresponding separator in the separator list.
		</method></inlet>
	</class>
	<class name="#centroid">
		<method name="init"/>
		<inlet id="0"><method name="grid(rows,columns,1)">
			will compute the centroid of the given grid, which
			is a weighted average, namely, the average position weighted
			by the pixel values.
		</method></inlet>
		<outlet id="0">
			<method name="grid(2)">
			result
			</method>
		</outlet>
	</class>
