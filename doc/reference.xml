	<class name="#store">
		A [#store] object can store exactly one grid, using the right
		inlet. You fetch it back, or selected subparts thereof, using the left
		inlet.

		<method name="init">
			<arg name="contents" type="grid"/>
		</method>

		<inlet id="0">
			<method name="bang">
				the stored grid is fully sent to the outlet.
			</method>
			<method name="grid"><arg name="grid" type="grid(dims..., indices)"/>
				in this grid, the last dimension refers to subparts of
				the stored grid. sending a Dim(200,200,2) on a [#store]
				that holds a Dim(240,320,3) will cause the [#store] to handle
				the incoming grid as a Dim(200,200) of Dim(2)'s, where each
				Dim(2) represents a position in a Dim(240,320) of Dim(3)'s.
				therefore the resulting grid will be a Dim(200,200) of
				Dim(3) which is a Dim(200,200,3). in practice this example
				would be used for generating a 200*200 RGB picture from a
				200*200 XY map and a 240*320 RGB picture. this object can
				be logically used in the same way for many purposes
				including color palettes, tables of probabilities, tables
				of statistics, whole animations, etc.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
			replace the whole grid, or a subpart of it (see other options on inlet 1)
			</method>
		</inlet>
		<inlet id="1">
			<method name="reassign">(Future Use): 
				makes it so that sending a grid to inlet 1 detaches the old buffer from [#store]
				and attaches a new one instead.  This is the default.
			</method>
			<method name="put_at"><rest name="indices"/>(Future Use): 
				makes it so that sending a grid to inlet 1 writes into the existing buffer of [#store].
				
				example: suppose you have [#store {10 240 320 3}]. then "put_at 3"
				will allow to write a Dim[240,320,3] grid in indices (3,y,x,c) where y,x,c are indices of the incoming grid;
				in other words, if that's a buffer of 10 RGB frames, you'd be replacing frame #3. Furthermore,
				it also allows you to write a Dim[n,240,320,3] grid at (3+f,y,x,c) where f,y,x,c are indices of the incoming grid,
				replacing frame #3, #4, ... up to #3+n-1. Here n is at most 7 because the last frame in the buffer is #9.
				
				that way of working extends to other kinds of data you'd put in Grids, in any numbers of dimensions;
				because, as usual, [#store] wouldn't know the difference.
				
			</method>
		</inlet>
		<outlet id="0">
			grids as stored, as indexed, or as assembled from multiple
			indexings.
		</outlet>
	</class>

	<class name="#scale_to">
		<method name="init">
			<arg name="size">{height width} pair.</arg>
		</method>

		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a 3-channel picture to be scaled.</method>
		</inlet>
		<inlet id="1">
			<method name="int">a {height width} pair.</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a scaled 3-channel picture.</method>
		</outlet>
	</class>

	<class name="#scale_by">
		<method name="init">
			<arg name="factor" type="grid dim() or dim(2)"/>
			factor is optional (default is 2).
			if it's a single value, then that factor is to be used
			for both rows and columns.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(y x channels)"/>
			duplicates each pixel several times in width and several times in height,
			where the number of times is determined by the factor described above.
			twice those of the incoming grid. It is several times faster.
			</method>
		</inlet>
		<inlet id="1"><method name="grid"><arg name="grid" type="grid(1 or 2)"/>sets factor</method></inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid((factor*y) (factor*x) channels)"/>
			</method>
		</outlet>
	</class>

	<class name="#downscale_by">
		<method name="init">
			<arg name="factor" type="+integer"/>
			<arg name="how" type="optional symbol(smoothly)"/>
			factor is optional (default is 2).
			if it's a single value, then that factor is to be used
			for both rows and columns.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(y x channels)"/>
			Scales down picture by specified amount. (See scale factor above)
			</method>
		</inlet>
		<inlet id="1"><method name="grid">
			<arg name="grid" type="grid(1 or 2)"/>sets scale factor</method></inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid((factor/y) (factor/x) channels)"/>
		</method>
		</outlet>
	</class>

	<class name="#spread">
		typically you plug a [#for] into this object,
		and you plug this object into the left side of a [#store]. it will
		scatter pixels around, giving an "unpolished glass" effect.
		
		if you put a picture in it, however, it will add noise. The
		resulting values may be out of range, so you may need to clip them
		using min/max.

		<method name="init">
			<arg name="factor">same as inlet 1</arg>
		</method>

		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a coordinate map.</method>
		</inlet>
		<inlet id="1">
			<method name="int">a spread factor.</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a coordinate map.</method>
		</outlet>


		[#spread] scatters the pixels in an image. Not all original pixels
		will  appear, and some may get duplicated (triplicated, etc)
		randomly. Some  wrap-around effect will occur close to the edges.
		

		 Sending an integer to inlet 1 sets the amount of spreading in
		maximum  number of pixels + 1. even values translate the whole image
		by half  a pixel due to rounding.

	</class>

	<class name="#rotate">
		performs rotations on indexmaps and polygons and such.
		
		<method name="init">
			<arg name="angle" type="0...35999"/>
		</method>
		<inlet id="0"><method name="grid">
			<arg name="grid" type="grid(anyA 2)"/></method></inlet>
		<inlet id="1"><method name="int">rotation angle; 0...36000</method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(anyA 2)"/>
		</method></outlet>
	</class>

	<class name="#remap_image">
		if you chain indexmap (coordinate) transformations from outlet 1
		to inlet 1, then sending an image in inlet 0 will emit its
		deformation out of outlet 0.

		<inlet id="0"/>
		<inlet id="1"/>
		<outlet id="0"/>
		<outlet id="1"/>
	</class>
	<class name="#dim">
		Returns list of dimensions as a grid. Given a grid sized like Dim(240,320,4), 
		[#dim] will return a grid like Dim(3), whose values are 240, 320, 4. 

		<method name="init">
			no arguments.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
				ignores any data contained within.
				sends a grid dim(length of dims) containing dims.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid(rank)"/>
				the list of dimensions of the incoming grid.
			</method>
		</outlet>
	</class>

	<class name="#type">
		gives a symbol representing the numeric type of the grid received.
		
		<outlet id="0"><method name="&lt;numeric type symbol&gt;"/></outlet>
	</class>

	<class name="display">
		GUI object equivalent to [print] and [#print].
		<method name="(any)">
		Displays the received message in the box, resizing the box so that the message fits exactly.
		</method>
	</class>
	<class name="#apply_colormap_channelwise">
		This object is useful for color correction. For each pixel
		it takes it apart, looks up each part separately in the colormap,
		and constructs a new pixel from that. You may also color-correct
		colormaps themselves.

		Only works for things that have 3 channels.

		Note: if you just need to apply a palette on an indexed-color
		picture, you don't need this. Just use #store instead.
		
		<inlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns channels)"/>
			picture
		</method></inlet>
		<inlet id="1">
			<method name="grid">
			<arg name="grid" type="grid(intensities channels)"/>
			colormap ("palette")
		</method></inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns channels)"/>
			picture
		</method></outlet>
	</class>

	<class name="#rgb_to_greyscale">
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {red green blue})"/>
		</method></inlet>
		<outlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {white})"/></method>
		</outlet>
	</class>

	<class name="#greyscale_to_rgb">
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {white})"/></method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns {red green blue})"/>
		</method></outlet>
	</class>

	<class name="#yuv_to_rgb">
		note: may change slightly to adapt to actual video standards.
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {y u v})"/></method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns {red green blue})"/>
		</method></outlet>
	</class>

	<class name="#rgb_to_yuv">
		note: may change slightly to adapt to actual video standards.
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {red green blue})"/></method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns {y u v})"/>
		</method></outlet>
	</class>
	<class name="#convolve">
		this is the object for blurring, sharpening, finding edges,
		embossing, cellular automata, and many other uses.
<!--NYI
		<attr name="seed">
		
		</attr>
-->
		<method name="init">
			<arg name="op_para" type="numop2"/>
			<arg name="op_fold" type="numop2"/>
			<arg name="seed"   type="grid"/>
			<arg name="right_hand" type="grid" default="none"/>
		</method>
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns rest...)"/>
				splits the incoming grid into dim(rest...) parts.
				for each of those parts at (y,x), a rectangle of such
				parts, centered around (y,x), is combined with the
				convolution grid like a [#] of operation op_para. Then
				each such result is folded like [#fold] of operation
				op_fold and specified base. the results are assembled
				into a grid that is sent to the outlet. near the borders of
				the grid, coordinates wrap around. this means the whole grid
				has to be received before production of the next grid
				starts.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid">
				<arg name="grid" type="grid(rows2 columns2)"/>
				this is the convolution grid and it gets stored in
				the object. if rows2 and/or columns2 are odd numbers,
				then the centre of convolution is the middle of the convolution
				grid. if they are even numbers, then the chosen centre will
				be slightly more to the left and/or to the top, because the
				actual middle is between cells of the grid.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns rest...)"/>
			</method>
		</outlet>
	</class>

	<class name="#text_to_image">
		inlet 2 receives a font grid, for example, [#in grid file lucida-typewriter-12.grid.gz]
		inlet 1 receives a 2 by 3 matrix representing the colours to use (e.g. (2 3 # 0 170 0 255 255 0) means yellow on green)
		inlet 0 receives a bang, transforming the data into an image suitable for #draw_image.
	</class>
	<class name="#hueshift">
		inlet 1 receives an angle (0..36000)
		inlet 0 receives a RGB picture that gets hueshifted by a rotation in the colorwheel by the specified angle; it gets sent to outlet 0.
	</class>
	<class name="pingpong">
		Transforms linear counting (0, 1, 2, 3, 4, ...)  into a back-and-forth counting (0, 1, 2, 1, 0, ...)
		from 0 to a specified upper bound.
		<method name="init">
			<arg name="top" type="int"/>
		</method>
		<inlet id="1">
			<method name="float"><arg name="top" type="float"/></method>
		</inlet>
		<inlet id="0">
			<method name="float">
				a value to be transformed.
				If, for example, top=10, then values 0 thru 10 are left unchanged,
				values 11 thru 19 are mapped to 9 thru 1 respectively, and 20 thru 30
				are mapped to 0 thru 10, and so on.
			</method>
		</inlet>
	</class>
	<class name="fps">
		<method name="init">
			<arg name="clocktype" type="symbol(real|user|system|cpu)">
				which clock to use. "real" uses wallclock time. "user" uses
				the amount of time spent in the process. "system" uses the
				amount of time spent in the kernel on behalf of the process.
				"cpu" uses the Pentium clock, which is like a more precise
				version of "real" if you have a Pentium.
			</arg>
			<arg name="detailed" type="symbol(detailed)">optional</arg>
		</method>
		<method name="init detailed">
		</method>
		<inlet id="0">
			<method name="bang">
			Times at which bangs are received are stored until a large
			enough sample of those is accumulated. Large enough is defined
			to be whenever the timespan exceeds one second. Then a report
			is made through the outlet.
			</method>
			<method name="(else)">
				messages other than bangs are ignored.
			</method>
		</inlet>
		<outlet id="0">
			<method name="float">
			non-detailed mode only.
			this is the messages-per-second rating.
			</method>
			<method name="list(float,6)">
			detailed mode only.
			this is: messages-per-second, followed by five values of
			milliseconds-per-message: minimum, median, maximum, average,
			standard deviation.
			(the average happens to be simply 1000 divided by the
			messages-per-second, but it is convenient to have it anyway)
			</method>
		</outlet>
	</class>
	<class name="fork">
		Every incoming message is sent to inlet 1 and then sent to
		inlet 0 as well. Messages remain completely unaltered. Contrast
		with PureData's "t a a" objects, which have the same purpose but
		transform bangs into zeros and such.

		<inlet id="0"><method name="(any)"/></inlet>
		<outlet id="0"/>
		<outlet id="1"/>
	</class>
	<class name="foreach">
		<inlet id="0"><method name="list"><rest/>
			Outputs N messages, one per list element, in order.
		</method></inlet>
	</class>
	<class name="listreverse">
		<inlet id="0"><method name="list"><rest/>
			Outputs the incoming list, from last element to first element.
		</method></inlet>
	</class>
	<class name="messageprepend">
		(This is not in jMax, but is there to help port $* messageboxes)
		<method name="init"><rest name="list" isattr="yes"/></method>
		<inlet id="0"><method name="&lt;any&gt;"><rest/>
			Like [listprepend], but operates on whole messages, that is, including the selector.
		</method></inlet>
		<inlet id="1" attr="list"/>
	</class>
	<class name="messageappend">
		(This is not in jMax, but is there to help port $* messageboxes)
		<method name="init"><rest name="list" isattr="yes"/></method>
		<inlet id="0"><method name="&lt;any&gt;"><rest/>
			Like [listappend], but operates on whole messages, that is, including the selector.
		</method>
		</inlet>
		<inlet id="1" attr="list"/>
	</class>
	<class name="range">
		<method name="init">
			<rest name="separators" type="float"></rest>
		</method>
		<inlet id="0"><method name="float">
			a value to be sent to one of the outlets. The first outlet is for values
			smaller than the first argument; else the second outlet is for values smaller
			than the second argument; and so on; and the last outlet is for values greater
			or equal to the last argument.
		</method></inlet>
		<inlet id="1..n"><method name="float">
			sets the corresponding separator in the separator list.
		</method></inlet>
	</class>
	<class name="#centroid">
		<method name="init"/>
		<inlet id="0"><method name="grid(rows,columns,1)">
			will compute the centroid of the given grid, which
			is a weighted average, namely, the average position weighted
			by the pixel values.
		</method></inlet>
		<outlet id="0">
			<method name="grid(2)">
			result
			</method>
		</outlet>
	</class>
