<?xml version="1.0" standalone="no" ?>
<!DOCTYPE jmax-doc SYSTEM 'jmax.dtd'>
<jmax-doc>
<!-- $Id$ -->
<!--
	GridFlow Reference Manual
	Copyright (c) 2001 by Mathieu Bouchard and Alexandre Castonguay
-->

<section name="Conventions of this Manual">
<prose>
	(In this section, usage of Bold, Italic, Courier, etc. would be explained.
	eventually I'd like those to have precise meanings consistent throughout
	the whole documentation)
</prose>
</section>

<section name="Grid Protocol">
<prose>
	<p><i>This section is useful is you want to do more than just pictures
	with GridFlow.
	</i></p>
	<p>
	each element of a grid is an integer. the range of allowed integer values 
	is called <i>signed 32-bit</i> and is -2147483648 to 2147483647 (which 
	is -2<sup>31</sup> to 2<sup>31</sup>-1).
	</p>
	<p>
	a single-dimensional grid of 3 elements (a triplet) is called dim(3). a
	three-dimensional grid of 240 rows of 320 columns of triplets is called
	dim(240,320,3).
	</p>
	<p>
	There is a sequence in which elements of a Grid are stored and
	transmitted.  Dimension 0 is called "outer" or "first" and dimension N-1 is
	called  "inner" or "last". They are called so because if you select a
	position in the first dimension of a grid, the selected part is of the same
	shape minus the first dimension; so in dim(240,320,3) if you select
	row 51 (or whichever valid row number), you get a dim(320,3). if you select
	a subpart two more times you get to a single number.
	</p>
	<p>
	At each such level, elements are sent/stored in their numeric order, 
	and are numbered using natural numbers starting at 0. This ordering usually 
	does not matter, but sometimes it does. Most notably, <k>@import</k>, 
	<k>@export</k> and <k>@redim</k> care about it. 
	</p>
	<p>
	On the other hand, order of dimensions usually does matter; this is 
	what distinguishes rows from columns and channels, for example.
	Most objects care about the distinction.
	</p>
	<p>
	A grid with only 1 element in a given dimension is different from one
	lacking that dimension; it won't have the same meaning. You can use this
	property to your advantage sometimes.
	</p>
	<p>
	Zero-dimensional grids exist. They are called dim(). They can only contain
	a single number.
	</p>
</prose>
</section>

<section name="Picture Protocol">
<prose>
	<p><i>This section is useful if you want to know what a picture is
	in terms of a grid.
	</i></p>

	<p>A picture is a three-dimensional Grid: 
	<list start="0">
		<li>rows</li>
		<li>columns</li>
		<li>channels</li>
	</list>
	</p>
	<p>Channels for the RGB color model are:
	<list start="0">
		<li>red</li>
		<li>green</li>
		<li>blue</li>
	</list>
	</p>
	<p>
	Because Grids are made of 32-bit integers, a three-channel picture uses 
	96 bpp (bits per pixel), and have to be downscaled to 24 bpp (or 16 bpp) 
	for display. That huge amount of slack is there because when you create 
	your own effects you often have intermediate results that need to be of 
	higher precision than a normal picture. Especially, results of multiplications 
	are big and should not overflow before you divide them back to normal; 
	and similarly, you can have negative values all over, as long as you take 
	care of them before they get to the display.
	</p>
	<p>
	In the final conversion, high bits are just ignored. This means: black is
	0, maximum is 255, and values wrap like with <k>% 256</k>. If you want to
	clip them, you may use <k>"@ max 0"</k> and <k>"@ min 255"</k> objects. 
	</p>
</prose>
</section>

<section name="Unary Operators">

	<!-- todo: text attr in those icons could be auto-generated -->

	<operator-1 name="abs" cname="abs">
		absolute value of A
	</operator-1>
	<operator-1 name="rand" cname="rand">
		randomly produces a non-negative number below A
	</operator-1>
	<operator-1 name="sqrt" cname="sqrt">
		square root of A, rounded downwards
	</operator-1>
</section>

<section name="Binary Operators">
	<prose>
		<p>In the following table, A is the value entered to the
		left, and B is the value entered to the right.</p>

		<p>Angles are in hundredths of degrees. This means a full circle
		(two pi radians) is 36000. You convert from degrees to our angles
		by multiplying by 100. You convert from radians to our angles by
		multiplying by 18000/pi.</p>

		<p>Hyperbolic functions (tanh) work with our angles too, so the
		same conversions apply. In case you wonder, there's a hidden link
		between Trigonometric and Hyperbolic functions that motivated me
		to use the same unit.</p>
	</prose>

	<!-- todo: text attr in those icons could be auto-generated -->
	<!-- todo: make CNAME a column in html -->

	<!-- category: additive -->
	<operator-2 name="+"    cname="add"> A + B </operator-2>
	<operator-2 name="-"    cname="sub"> A - B </operator-2>
	<operator-2 name="inv+" cname="bus"> B - A </operator-2>

	<!-- category: multiplicative -->
	<operator-2 name="*"     cname="mul"> A * B </operator-2>
	<operator-2 name="/"     cname="div"> A / B, rounded downwards </operator-2>
	<operator-2 name="inv*"  cname="vid"> B / A, rounded downwards </operator-2>
	<operator-2 name="%"     cname="mod"> A % B, non-negative remainder </operator-2>
	<operator-2 name="swap%" cname="dom"> B % A, non-negative remainder </operator-2>

	<!-- bits -->
	<operator-2 name="|"     cname="or" > A or B, bitwise  </operator-2>
	<operator-2 name="^"     cname="xor"> A xor B, bitwise </operator-2>
	<operator-2 name="&amp;" cname="and"> A and B, bitwise </operator-2>
	<operator-2 name="&lt;&lt;" cname="shl">
		A * (2**(B % 32)), which is left-shifting
	</operator-2>
	<operator-2 name="&gt;&gt;" cname="shr">
		A / (2**(B % 32)), which is right-shifting
	</operator-2>

	<!-- decision -->
	<operator-2 name="||" cname="sc_or"> if A is zero then B else A </operator-2>
	<operator-2 name="&amp;&amp;" cname="sc_and"> if A is zero then zero else B</operator-2>
	<operator-2 name="min" cname="min"> the lowest value in A,B </operator-2>
	<operator-2 name="max" cname="max"> the highest value in A,B </operator-2>

	<!-- comparison -->
	<operator-2 name="cmp"   cname="cmp"> -1 when A&lt;B; 0 when A=B; 1 when A&gt;B. </operator-2>
	<operator-2 name="=="    cname="eq"> is A equal to B ? 1=true, 0=false </operator-2>
	<operator-2 name="!="    cname="ne"> is A not equal to B ? </operator-2>
	<operator-2 name="&gt;"  cname="gt"> is A greater than B ? </operator-2>
	<operator-2 name="&lt;=" cname="le"> is A not greater than B ? </operator-2>
	<operator-2 name="&lt;"  cname="lt"> is A less than B ? </operator-2>
	<operator-2 name="&gt;=" cname="ge">is A not less than B ? </operator-2>

	<!-- trigonometrics and exponentiation -->
	<operator-2 name="sin*" cname="sin"> B * sin(A) </operator-2>
	<operator-2 name="cos*" cname="cos"> B * cos(A) </operator-2>
	<operator-2 name="atan" cname="atan"> arctan(A/B) </operator-2>
	<operator-2 name="tanh" cname="tanh"> tanh(A) </operator-2>
	<operator-2 name="gamma" cname="gamma"> floor(pow(a/256.0,256.0/b)*256.0) </operator-2>
	<operator-2 name="**" cname="pow"> A raised to power B </operator-2>
</section>

<section name="Objects for Input/Output">

	<jmax-class name="@in">
		<icon
			image="images/@in.jpg"
			text="[@in]"
		/>

		<method name="init">
			Creates an input object for an unspecified format. You
			need to use the <k>open</k> command to decide that.

			Remember that most formats produce dim(rows,columns,3) grids with
			0-255 values. (Most.)
		</method>

		<inlet id="0">
			<method name="open" min="1">
				<arg name="format"/>
				<rest name="format_specific_part"/>
				This is the command that gives a particular resource
				to a @out object. This is done through a "format"
				(there is a list of formats in this manual). The other
				arguments depend on the chosen format. The format may
				be a file format or a protocol or a hardware device, etc.
			</method>
			<method name="close">
				close may be necessary if you operate on "/dev/video",
				which can only be read by one at a time. otherwise it's
				usually not necessary.
			</method>
			<method name="bang">
				sends a grid through the outlet. the grid may be the
				result of reading from a file, acquiring from a device,
				capturing from the screen etc.

				this is format-specific. most formats
				produce <dim>rows columns {red green blue}</dim>.

				In formats that read from a file, reading another picture
				will continue if several pictures are concatenated in the
				file, but if the end of file is reached instead, it will
				rewind and send the first picture again.

				see section "External Picture Formats".

			</method>
			<method name="option">
				<arg name="selector" type="symbol"/>
				<rest name="stuff"/>
				for format-specific options.
				(usually in devices that masquerade as formats).

				see section "External Picture Formats".
			</method>
		</inlet>
		<sample
			image="images/grab_video_in.png"
		/>
	</jmax-class>

	<jmax-class name="@out">
		<icon
			image="images/@out.jpg"
			text="[@out]"
		/>
		<method name="init">
			Creates an output object for an unspecified format. You
			need to use the <k>open</k> command to decide that.

			Remember that most formats expect dim(rows,columns,3) grids with
			0-255 values. (Most.)
		</method>
		<method name="init">
			<arg name="rows" type="integer"/>
			<arg name="columns" type="integer"/>

			This alternate way to create an @out automatically calls
			"open x11 here" and "option out_size <i>rows columns</i>".
		</method>
		<inlet id="0">
			<method name="open" min="1">
				<arg name="format"/>
				<rest name="format_specific_part"/>
				This is the command that gives a particular resource
				to a @out object. This is done through a "format"
				(there is a list of formats in this manual). The other
				arguments depend on the chosen format. The format may
				be a file format or a protocol or a hardware device, etc.
			</method>
			<grid>
				this is format-specific. most formats
				expect <dim>rows columns {red green blue}</dim>.

				In formats that write to a file, sending a 2nd picture
				overwrites the first.

				see section "External Picture Formats".
			</grid>
			<method name="close">
				closes the file. usually not necessary.
			</method>
			<method name="option">
				<arg name="selector" type="symbol"/>
				<rest name="stuff"/>
				for format-specific options.
				(usually in devices that masquerade as formats).

				see section "External Picture Formats".
			</method>
			<method name="option timelog">
				<arg name="status" type="0,1"/>
				when status=1, current time (unix clock) and time since last
				frame-end are printed in the console. when status=0, it is off.
				default is 0.
			</method>

		</inlet>
		<outlet id="0">
			<method name="bang">
				sent when a complete grid has been received.
			</method>
		</outlet>
		<sample
			image="images/grab_video_out_file.png"
			text="[@out]"
		/>
	</jmax-class>

	<jmax-class name="@import">
		<icon
			image="images/@import_240_320_3.jpg"
			text="[@ import 240 320 3]"
		/>

		<p>This object allows you to import non-grid jMax data, such as
		integers and lists of integers. This object also reframes/resyncs
		integers and grids so that multiple grids may be joined together, or
		single grids may be split.</p>

		<method name="init">
			<rest name="dims" type="+integer"/>
			the argument list specifies a grid shape that the numbers
			will fit into.
		</method>
		<inlet id="0">
			<method name="int">
				begins a new grid if there is no current grid.
				puts that integer in the current grid.
				ends the grid if it is full.
				the constructed grid is not stored: it is streamed.
				the stream is buffered, so the output is in packets
				of about a thousand numbers.
			</method>
			<method name="reset">
				aborts the current grid if there is one.
			</method>
			<grid><dim>dims...</dim>
				this is the equivalent of filtering this grid through
				an @export object and sending the resulting integers
				to this @import object, except that it's about
				10 times faster.
			</grid>
		</inlet>
		<inlet id="1">
			<grid><dim>rank</dim>
				this grid is a dimension list that replaces the one
				specified in the constructor.
			</grid>
		</inlet>
		<outlet id="0">
			<grid>
				the grid produced from incoming integers and/or grids.
			</grid>
		</outlet>
		<sample
			image="images/grab_import.png"
			text="[@import 240 320 3]"
		/>
	</jmax-class>

	<jmax-class name="@export">
		<icon
			image="images/@export.jpg"
			text="[@export]"
		/>
		<p>this object is the opposite of @import.</p>
		<method name="init">
			this object is not configurable because there isn't
			anything that could possibly be configured here.
		</method>
		<inlet id="0">
			<grid><dim>dims...</dim>
				transforms this grid in a series of integers.
			</grid>
		</inlet>
		<outlet id="0">
			<method name="int">
				elements of the incoming grid.
			</method>
		</outlet>
		<sample
			image="images/grab_export.png"
			text="[@export]"
		/>
	</jmax-class>

	<jmax-class name="@two">
		<icon
			image="images/@two.jpg"
			text="[@two]"
		/>
		<p> holds two values, defaulting to (0,0). each time one is
		changed (by sending an integer in that inlet), a dim(2) grid is
		sent through the outlet.</p>
		<method name="init">no arguments.</method>
		<inlet id="0"><method name="int"/></inlet>
		<inlet id="1"><method name="int"/></inlet>
		<outlet id="0"><grid><dim>2</dim></grid></outlet>
		<sample
			image="images/grab_two.png"
			text="[@two]"
		/>
	</jmax-class>

	<jmax-class name="@three">
		<icon
			image="images/@three.jpg"
			text="[@three]"
		/>
		<p> holds three values, defaulting to (0,0,0). each time one is
		changed (by sending an integer in that inlet), a dim(3) grid is
		sent through the outlet.</p>
		<method name="init">no arguments.</method>
		<inlet id="0"><method name="int"/></inlet>
		<inlet id="1"><method name="int"/></inlet>
		<inlet id="2"><method name="int"/></inlet>
		<outlet id="0"><grid><dim>3</dim></grid></outlet>
		<sample
			image="images/grab_three.png"
			text="[@three]"
		/>
	</jmax-class>

	<jmax-class name="@four">
		<p> holds four values, defaulting to (0,0,0,0). each time one is
		changed (by sending an integer in that inlet), a dim(4) grid is
		sent through the outlet.</p>
		<method name="init">no arguments.</method>
		<inlet id="0"><method name="int"/></inlet>
		<inlet id="1"><method name="int"/></inlet>
		<inlet id="2"><method name="int"/></inlet>
		<inlet id="3"><method name="int"/></inlet>
		<outlet id="0"><grid><dim>4</dim></grid></outlet>
	</jmax-class>
</section>

<section name="Objects for Generating">
	<jmax-class name="@for">
		<icon
			image="images/@for.jpg"
			text="[@for 0 320 1]"
		/>
		<p>works like a regular [for] object plugged to a [@import] tuned
		for a dim(size) where size is the number of values produced by a bang
		to that [for].</p>
		<method name="init">
			<arg name="from" type="integer"/>
			<arg name="to" type="integer"/>
			<arg name="step" type="integer"/>
		</method>
		<inlet id="0"><method name="int">
			replaces the "from" value and produces output.
		</method></inlet>
		<inlet id="1"><method name="int">
			replaces the "to" value.
		</method></inlet>
		<inlet id="2"><method name="int">
			replaces the "step" value.
		</method></inlet>
		<outlet id="0">
			<grid><dim>size</dim>
				where size is floor((to-from+1)/step)
			</grid>
		</outlet>
	</jmax-class>
</section>

<section name="Objects for Computing">
	<jmax-class name="@">
		<p>This object computes a grid by computing "in parallel" a same
		operation on each left-hand element with its corresponding right-hand
		element. This is a massively parallel version of jMax's builtin
		arithmetic operators. In case you wonder, it's only parallel in the
		sense that all those computations are independent; there's no
		guarantee about how many of them will actually be computed at once.
		</p>

		<method name="init">
			<arg name="operator" type="symbol"/>
			<arg name="value" type="integer"/>
			the operator is one picked in the table of the 30 binary
			operators. the value (optional, zero by default) becomes
			the initial value of the right inlet.
		</method>

		<inlet id="0">
			<grid><dim>dims...</dim>
				on each element of this grid, perform the operation
				together with the corresponding element of inlet 1.
				in the table of operators (at the top of this document)
				elements of inlet 0 are called "A" and elements of inlet 1
				are called "B". the resulting grid is the same size as the
				one in inlet 0.
			</grid>
		</inlet>
		<inlet id="1">
			<grid><dim>dims...</dim>
				any grid, preferably shaped like the one that will be put
				in the left inlet, or like a subpart of it (the contents
				will be redim'ed on the fly to fit the grid of inlet-0,
				but the stored grid will not be modified itself)
			</grid>
			<method name="int">
				stores a single int in the right inlet; the same int will
				be applied in all computations; this is like sending a
				dim(1) or dim() grid with that number in it.
			</method>
		</inlet>
		<outlet id="0">
			<grid>
			</grid>
		</outlet>
	
		<sample
			image="images/grab_binary_operations.png"
			text="binary operators 1"
		/>
	</jmax-class>

	<jmax-class name="@!">
		<p>This object computes a grid by computing "in parallel" a same
		operation on each element of the grid.
		</p>
		
		<method name="init">
			<arg name="operator" type="symbol"/>
			the operator is one picked in the table of the 3 unary
			operators. they are "unary" because they take only one
			value.
		</method>
		<inlet id="0">
			<grid>
			</grid>
		</inlet>
		<outlet id="0">
			<grid>
			</grid>
		</outlet>
	</jmax-class>

	<jmax-class name="@fold">
		<icon
			image="images/@fold_%2B.jpg"
			text="[@fold +]"
		/>
		<p>
		@fold makes the last dimension of a grid disappear by combining elements
		together in each innermost array. For example, @fold + 0 on a RGB image
		will output a channelless image in which every value is the sum of
		red/green/blue values in a pixel. The zero is the starting value, so that
		is actually 0+r+g+b. You can get the number of values in a grid by passing
		it through @dim and then through @fold * 1.
		</p>

		<method name="init">
			<arg name="operator" type="symbol"/>
			<arg name="base" type="integer"/>
			the base value is optional and defaults to 0.
			the operator is one from the table of binary operators.
		</method>
		
		<inlet id="0">
			<grid><dim>dims..., last</dim>
				produces a dim(dims) grid (the last dimension is removed).
				the incoming grid is split into dim(last) subparts; from
				each of those parts a result is produced by cascading the
				specified operation from the base value (specified in
				inlet 1) to all the elements in that subpart. (see examples
				below)
			</grid>
		</inlet>
		<inlet id="1">
			<method name="int">
				changes the base value to use.
			</method>
		</inlet>
		<outlet id="0">
		</outlet>

		<p>examples: [@fold +] is a sum of all elements (on the last
		dimensions); similarly, [@fold inv+] is an alternated sum, and [@fold
		* 1] is a product; [@fold &amp; 1] can be used to mean "for all";
		[@fold | 0] can be used to mean "there exists (at least one)";
		[@fold ^ 0] can be used to mean "there exists an odd number of..."
		and [@fold ^ 1] "there exists an even number of...".</p>

		<sample
			image="images/grab_fold.png"
			text="[@fold +]"
		/>
	</jmax-class>

	<jmax-class name="@outer">
		<icon
			image="images/@outer.jpg"
			text="[@outer +]"
		/>

		<method name="init">
			<arg name="operator" type="symbol"/>
			the operator must be picked from the table of binary operators.
		</method>

		<inlet id="0">
			<grid><dim>anyA...</dim></grid>
			produces a grid of size dim(anyA..., anyB...), where numbers
			are the results of the operation on every element of A and
			every element of B. the resulting array can be very big. Don't
			try this on two pictures (the result will have 6 dimensions)
		</inlet>
		<inlet id="1">
			<grid><dim>anyB...</dim></grid>
			stores the specified grid, to be used when inlet 0 is activated.
		</inlet>
		<outlet id="0">
		</outlet>

		<p>When given a grid of Dim(3) and a grid of Dim(5) [@outer] will
		produce  a grid of Dim(3,5) with the selected binary operation
		applied on each  of the possible pairs combinations between numbers
		from the left grid  and the ones from the right. for example :
		(10,20,30) [@outer +] (1,2,3)  will give :
		((11,12,13),(21,22,23),(31,32,33)) </p>

		<sample
			image="images/grab_outer.png"
			text="[@dim]"
		/>
	</jmax-class>

	<jmax-class name="@inner">
		<icon
			image="images/@inner.jpg"
			text="[@inner * + 0]"
		/>

		<p>think of this one as a special combination of [@outer], [@],
		and [@fold]. this is one of the most complex operations. It is very
		useful for performing linear transforms like rotations, scalings,
		tilts, and color remappings.
		</p>

		<method name="init">
			<arg name="op_para" type="symbol"/>
			<arg name="op_fold" type="symbol"/>
			<arg name="base"    type="integer"/>
			op_para and op_fold are two operators picked from the table
			of binary operators.
			the base value has to be specified (has no default value yet).
		</method>
		<inlet id="0">
			<grid><dim>anyA..., lastA</dim>
				creates a dim(anyA...,anyB...) grid by splitting the
				left-hand grid into dim(lastA) pieces, the right-hand grid
				into dim(lastB) pieces, doing an [@] on them with the
				specified op_para operator, and then a [@fold] on that with
				the specified op_fold operator and base value. lastA must be
				equal to lastB.
			</grid>
		</inlet>
		<inlet id="1">
			<method name="int">
				changes the base value to that.
			</method>
		</inlet>
		<inlet id="2">
			<grid><dim>anyB..., lastB</dim>
				changes the right-hand side grid to that.
			</grid>
		</inlet>
		<outlet id="0">
		</outlet>
	</jmax-class>
</section>

<section name="Objects for Coordinate Transforms">
	<jmax-class name="@redim">
		<icon
			image="images/@redim.jpg"
			text="[@redim 2]"
		/>

		<method name="init">
			<rest name="dims" type="+integer"/>
			the argument list specifies a grid shape that the numbers
			will fit into.
			(same as with @import)
		</method>
		<inlet id="0">
			<grid><dim>dims...</dim>
			the elements of this grid are serialized. if the resulting grid
			must be larger, the sequence is repeated as much as necessary.
			if the resulting grid must be smaller, the sequence is truncated.
			then the elements are deserialized to form the resulting grid.
			</grid>
		</inlet>
		<inlet id="1">
			<grid><dim>rank</dim>
				this grid is a dimension list that replaces the one
				specified in the constructor.
				(same as with @import)
			</grid>
		</inlet>
		<outlet id="0">
			<grid>
				redimensioned grid potentially containing repeating data.
			</grid>
		</outlet>

		<p>example: with a 240 320 RGB image, @redim 120 640 3 will visually
		separate the even lines (left) from the odd lines (right). contrary
		to this, @redim 640 120 3 will split every line and put its left half
		on a even line and the right half on the following odd line. @redim
		480 320 3 will repeat the input image twice in the output image.
		@redim 240 50 3 will only keep the 50 top lines.</p>

		<sample
			image="images/grab_redim.png"
			text="[@redim 2]"
		/>
	</jmax-class>
	<jmax-class name="@store">
		<icon
			image="images/@store.jpg"
			text="[@store]"
		/>

		<p>A @store object can store exactly one grid, using the right
		inlet. You fetch it back, or selected subparts thereof, using the left
		inlet.</p>

		<method name="init">
			<arg name="number_type" type="int32 | uint8"/>
			The number type argument is optional and by default is int32,
			which allows the usual range of plus/minus two billions. With
			uint8, values are wrapped into the 0..255 interval, and stored
			in four times less memory.
		</method>

		<inlet id="0">
			<method name="bang">
				the stored grid is fully sent to the outlet.
			</method>
			<grid><dim>dims..., indices</dim>
				in this grid, the last dimension refers to subparts of
				the stored grid. sending a dim(200,200,2) on a @store
				that holds a dim(240,320,3) will cause the @store to handle
				the incoming grid as a dim(200,200) of dim(2)'s, where each
				dim(2) represents a position in a dim(240,320) of dim(3)'s.
				therefore the resulting grid will be a dim(200,200) of
				dim(3) which is a dim(200,200,3). in practice this example
				would be used for generating a 200*200 RGB picture from a
				200*200 XY map and a 240*320 RGB picture. this object can
				be logically used in the same way for many purposes
				including color palettes, tables of probabilities, tables
				of statistics, whole animations, etc.
			</grid>
		</inlet>
		<inlet id="1">
			<grid><dim>dims...</dim>
				the received grid is stored. if the storage type is uint8,
				the input is filtered to fit 0..255.
			</grid>
		</inlet>
		<outlet id="0">
			grids as stored, as indexed, or as assembled from multiple
			indexings.
		</outlet>
		<sample
			image="images/grab_cross_fade.png"
			text="[@store]"
		/>
	</jmax-class>

	<jmax-class name="@identity_transform">
		<icon
			image="images/@identity_transform.jpg"
			text="[@identity_transform]"
		/>

		<method name="init">
			no arguments.
		</method>

		<inlet id="0">
			<method name="bang">creates a coordinate map that can
			be fed into the left input of @store to give the same result
			as a bang in that input; that coordinate map is
			dim(height,width,2), where each dim(2) is a (y,x) pair indexing
			a pixel.</method>
		</inlet>
		<inlet id="1">
			<method name="int">a height.</method>
		</inlet>
		<inlet id="2">
			<method name="int">a width.</method>
		</inlet>
		<outlet id="0">
			<grid>a coordinate map.</grid>
		</outlet>

<p>@identity_transform builds a pixel-level transform grid suitable for 
using with inlet 0 of @store. </p>
<p> Sending an integer to inlet 2 sets the width of the resulting picture.</p>
<p> Sending an integer to inlet 1 sets the height of the resulting picture.</p>
<p> Sending a grid to inlet 0 generates said grid and sends it to inlet 
0. Not guaranteed to be fast (use an intermediate @store as a cache 
if needed)</p>

		<sample
			image="images/grab_identity_transform.png"
			text="[@identity_transform]"
		/>
	</jmax-class>

	<jmax-class name="@scale_to">
		<icon
			image="images/@scale_to.jpg"
				text="[@scale_to]"
		/>

		<method name="init">
			no arguments.
		</method>

		<inlet id="0">
			<grid>a picture to be scaled.</grid>
		</inlet>
		<inlet id="1">
			<method name="int">a height.</method>
		</inlet>
		<inlet id="2">
			<method name="int">a width.</method>
		</inlet>
		<outlet id="0">
			<grid>a scaled picture.</grid>
		</outlet>


<p>@scale_to is normally fed the same inlet 1,2 values as @identity_transform, 
and chained from @identity_transform and to @store. This will scale an 
image of any size to the size specified in inlets 1,2. If it doesn't correspond 
the values of @identity_transform, part of the image will be trimmed and/or 
duplicated.</p>

		<sample
			image="images/grab_scale_to.png"
			text="[@scale_to]"
		/>
	</jmax-class>
	
	<jmax-class name="@spread">
		<icon
			image="images/@spread.jpg"
			text="[@spread]"
		/>

		<p>typically you plug a @identity_transform into this object,
		and you plug this object into the left side of a @store. it will
		scatter pixels around, giving an "unpolished glass" effect.</p>

		<method name="init">
			no arguments.
		</method>

		<inlet id="0">
			<grid>a coordinate map.</grid>
		</inlet>
		<inlet id="1">
			<method name="int">a spread factor.</method>
		</inlet>
		<outlet id="0">
			<grid>a coordinate map.</grid>
		</outlet>


	<p>@spread scatters the pixels in an image. Not all original pixels will 
	appear, and some may get duplicated (triplicated, etc) randomly. Some 
	wrap-around effect will occur close to the edges. </p>
	<p> Sending an integer to inlet 1 sets the amount of spreading in maximum 
	number of pixels + 1. even values translate the whole image by half 
	a pixel due to rounding.</p>

		<sample
			image="images/grab_spread.png"
			text="[@spread]"
		/>
	</jmax-class>
</section>

<section name="Reporting Objects">
	<jmax-class name="@dim">
		<icon image="images/@dim.jpg" text="[@dim]"/>
		<p>Returns list of dimensions as a grid. Given a grid sized like Dim(240,320,4), 
		@dim will return a grid like Dim(3), whose values are 240, 320, 4. </p>

		<method name="init">
			no arguments.
		</method>
		<inlet id="0">
			<grid><dim>dims...</dim>
				ignores any data contained within.
				sends a grid dim(length of dims) containing dims.
			</grid>
		</inlet>
		<outlet id="0">
			<grid><dim>rank</dim>
				the list of dimensions of the incoming grid.
			</grid>
		</outlet>

		<sample image="images/grab_dim.png"/>
	</jmax-class>
	<jmax-class name="@print">
		<p>future use</p>
	</jmax-class>
</section>

<section name="Objects intended for Picture Processing">
	<jmax-class name="@convolve">

		<p>this is the object for blurring, sharpening, finding edges,
		embossing, and many other uses.</p>

		<method name="init">
			<arg name="op_para" type="symbol"/>
			<arg name="op_fold" type="symbol"/>
			<arg name="base"   type="integer"/>
		</method>
		<inlet id="0">
			<grid><dim>rows columns rest...</dim>
				splits the incoming grid into dim(rest...) parts.
				for each of those parts at (y,x), a rectangle of such
				parts, centered around (y,x), is combined with the
				convolution grid like a [@] of operation op_para. Then
				each such result is folded like [@fold] of operation
				op_fold and specified base. the results are assembled
				into a grid that is sent to the outlet. near the borders of
				the grid, coordinates wrap around. this means the whole grid
				has to be received before production of the next grid
				starts.
			</grid>
		</inlet>
		<inlet id="1">
			<grid><dim>rows2 columns2</dim>
				this is the convolution grid and it gets stored in
				the object. rows2 and columns2 must be odd numbers.
			</grid>
		</inlet>
		<outlet id="0">
			<grid><dim>rows columns rest...</dim>
			</grid>
		</outlet>
	</jmax-class>

	<jmax-class name="@scale_by">
		<method name="init">
			no arguments. scales by 2.
		</method>
		<method name="init">
			<arg name="factor"/>
			future use: will scale by that factor.
		</method>
		<method name="init">
			<arg name="factor_y"/>
			<arg name="factor_x"/>
			future use: will scale by those factors.
		</method>
		<inlet id="0">
			<grid><dim>y x {r g b}</dim>
			identical to @scale_to with arguments that are exactly
			twice those of the incoming grid. It is several times faster.
			</grid>
		</inlet>
		<outlet id="0">
			<grid><dim>y x {r g b}</dim></grid>
		</outlet>
	</jmax-class>

	<jmax-class name="@contrast">
		<icon
			image="images/@contrast.jpg"
			text="[@contrast]"
		/>

		<method name="init">
			no arguments.
		</method>
		
		<inlet id="0">
			<grid><dim>rows columns channels</dim>
			produces a grid like the incoming grid but with
			different constrast.
			</grid>
			<p>@contrast adjusts the intensity in an image.
			resulting values outside 0-255 are automatically clipped.</p>
		</inlet>
		<inlet id="1">
			<method name="int">
			this is the secondary contrast. it makes the incoming black
			correspond to a certain fraction between output black and the
			master contrast value. no effect is 256. default value is 256.
			</method>	
		</inlet>
		<inlet id="2">
			<method name="int">
			this is the master contrast. it makes the incoming white
			correspond to a certain fraction between output black and output
			white. no effect is 256. default value is 256.
			</method>	
		</inlet>
		<outlet>
			<grid><dim>rows columns channels</dim>
			</grid>
		</outlet>
		<sample
			image="images/grab_contrast.png"
			text="[@contrast]"
		/> 
	</jmax-class>

	<jmax-class name="@posterize">
		<icon
			image="images/@posterize.jpg"
			text="[@posterize]"
		/>

		<p>@posterize reduces the number of possible intensities in an image;
		it rounds the color values.The effect is mostly apparent with a low
		number of levels.</p>

		<method name="init">
			no arguments.
		</method>

		<inlet id="0">
			<grid><dim>rows columns channels</dim>
				produces a posterized picture from the input picture.
			</grid>
		</inlet>

		<inlet id="1">
			<method name="int">
				this is the number of possible levels per channel. the
				levels are equally spaced, with the lowest at 0 and the
				highest at 255. the minimum number of levels is 2, and the
				default value is 2.
			</method>
		</inlet>
		
		<outlet id="0">
		</outlet>

		<p>example: simulate the 216-color "web" palette using 6 levels.
		simulate a 15-bit display using 32 levels.</p>

	<sample
		image="images/grab_posterize.png"
		text="[@posterize]"
	/>
</jmax-class>

</section>

<section name="Special Objects">
	<jmax-class name="rtmetro">
		future use.
	</jmax-class>

	<jmax-class name="@global">
		<p>
		objects of this class do nothing by themselves and are just
		an access point to features that don't belong to any object in
		particular.
		</p>
		<method name="profiler_reset">
			resets all the time counters.
		</method>
		<method name="profiler_dump">
			displays the time counters in decreasing order, with
			the names of the classes those objects are in. this is
			an experimental feature. like most statistics,
			it could be vaguely relied upon if
			only you knew to which extent it is unreliable. more on this
			in a future section called "profiling".
		</method>
	</jmax-class>
</section>

<section name="External Picture Formats">

	<jmax-class name="format ppm @in/@out">
		<icon
			image="images/format_ppm.jpg"
			text="[open ppm file filename.ppm]"
		/>

		<p>Subformat P6 only.
		Max-number can only be 255 (24-bit RGB).
		</p>

		<method name="open ppm file">
			<arg name="filename" type="symbol"/>
			opens the specified file, taken from the current
			directory or one of the jMax-specified data directories.
		</method>

		<grid><dim>rows columns 3</dim>
			values 0-255
		</grid>
	</jmax-class>

	<jmax-class name="format targa @in">
		<icon
			image="images/format_targa.jpg"
			text="[open targa file filename.tga]"
		/>
		<p>Support for RGB-24 (3 channels).
		If you bug me a bit you'll get ARGB-32 too.</p>

		<method name="open ppm file">
			<arg name="filename" type="symbol"/>
			opens the specified file, taken from the current
			directory or one of the jMax-specified data directories.
		</method>

		<grid><dim>rows columns 3</dim>
			values 0-255
		</grid>
	</jmax-class>

	<jmax-class name="format grid @in/@out">
		<icon
			image="images/format_grid.jpg"
			text="[open grid file filename.grid]"
		/>
		<icon
			image="images/format_grid_tcp.jpg"
			text="[open grid tcp www.artengine.ca 4242]"
		/>

		<method name="open file">
			<arg name="filename" type="symbol"/>
			opens the specified file, taken from the current
			directory or one of the jMax-specified data directories.
		</method>
		<method name="open tcp">
			<arg name="hostname" type="symbol"/>
			<arg name="port" type="integer"/>
			dials an specified hostname/port on the InterNet or
			compatible network. the TCP protocol is used.
		</method>
		<method name="open tcpd">
			<arg name="port" type="integer"/>
			future use:
			waits for a call (and answers) for this port on the
			local machine via InterNet or compatible network.
			Answers the call.
		</method>

		<p>
		This is GridFlow's special file format. This is the only I/O
		format that can hold absolutely anything that the [@store] object can.
		However this can only be stored in 32 bits-per-value.
		</p>
		<p>
		This is the only picture format that currently supports TCP
		connections. This is still somewhat clunky: the socket only
		opens in client mode only; and upon bang, jMax freezes until
		the whole grid is received.
		</p>
	</jmax-class>

	<jmax-class name="format videodev @in">
		<icon
			image="images/format_videodev.jpg"
			text="[open videodev /dev/video0]"
		/>

		<p>Video4Linux-1 devices, RGB-24 only. Variable picture size.
		should work for bttv based cards and the dc1 from miro, possibly 
		dc10plus.</p>

		<p>If you suffer from color inversion, you may feed the list
		"<k>0 0 1 0 1 0 1 0 0</k>" to a [@redim 3 3] and feed that to the
		right side of a <k>[@inner * + 0]</k>. Use that @inner object as a
		RGB-BGR converter.</p>

		<p>color adjustments:
		<method name="option brightness"><arg name="level" type="0-65535"/></method>
		<method name="option hue"       ><arg name="level" type="0-65535"/></method>
		<method name="option colour"    ><arg name="level" type="0-65535"/></method>
		<method name="option contrast"  ><arg name="level" type="0-65535"/></method>
		<method name="option whiteness" ><arg name="level" type="0-65535"/></method>
		</p>
		
		<p>other options:
		<method name="option channel"   ><arg name="level" type="integer"/></method>
		<method name="option tuner"     ><arg name="level" type="integer"/></method>
		<method name="option norm"      ><arg name="level" type="integer"/></method>
		</p>

		<method name="option size">
			<arg name="height"/>
			<arg name="width"/>
			sets the input size, especially when using a video digitalizer
			device
		</method>
	</jmax-class>

	<jmax-class name="format x11 @in/@out">

		<icon
			image="images/format_x11.jpg"
			text="[open x11 here]"/>

		<method name="open x11 here">
			connects to the default X11 server,
			according to your environment variable "DISPLAY".
		</method>

		<method name="open x11 local">
			<arg name="display_number" type="integer"/>
			connects to a display server on this machine.
		</method>
		
		<method name="open x11 remote">
			<arg name="host_name" type="symbol"/>
			<arg name="display_number" type="integer"/>
			connects to a remote X11 display server using TCP.
			Sorry, IP addresses are not supported (jMax limitation).
			Port number will be 6000 plus the display number, because
			of the X11 standard.
		</method>
		
		<grid><dim>rows columns {red green blue}</dim>
			resizes the window to the size of the grid;
			encodes that grid in the display's pixel format;
			also displays it if autodraw &gt; 0
			the values must be in range 0-255,
			or else they will be "wrapped".
		</grid>

		<method name="bang">
			see format x11's option draw.
		</method>

		<method name="autodraw">
			<arg type="integer"/>
			see format x11's option autodraw.
		</method>

		<p>
		Destroying the object (or sending "close") should close the window.
		Because of how jMax works,
		this may be delayed until you do something else.
		</p>

		<p>because of the design of Xlib, or if any of the connections
		involved crashes, then the whole program (fts) has to be terminated.
		(don't you love xlib). Something similar happens if you close any
		of the windows yourself, but IIRC this could be fixed.</p>

		<p>only one window may be used per connection (to simplify matters;
		this doesn't reduce flexibility).</p>

		<p>there is an additional argument that may be added to every
		"open" message; if you don't put it, a new toplevel window is created.
		if you put "root" then the screen's wallpaper will be used instead
		(it may fail to work with some popular window managers). You can also
		put a window number, e.g. <k>0x28003ff</k>, you may connect to
		an existing window; you can find out the number of a window by using
		a tool like <k>xwininfo</k>, part of X11 standard tools.</p>

		<method name="option out_size">
			<arg name="height" type="integer"/>
			<arg name="width"  type="integer"/>
			changes the window's size, just like sending a grid
			dim(height,width,3) would.
		</method>
		
		<method name="option draw">
			forces a redraw of the window's contents.
		</method>

		<method name="option autodraw">
			<arg name="level" type="0,1,2"/>
			<list start="0">
			<li>option draw() is never automatically invoked</li>
			<li>option draw() is invoked after each grid is finished</li>
			<li>option draw() is invoked incrementally after each row is
			received. (but buffering may cause lines to come in groups
			anyway)</li>
			</list>
		</method>

		<sample
			image="images/grab_video_out.png"
			text="video_out_patch"
		/>
	</jmax-class>
</section>
</jmax-doc>
