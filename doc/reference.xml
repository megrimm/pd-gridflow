<?xml version="1.0" standalone="no" ?>
<!DOCTYPE documentation SYSTEM 'jmax.dtd'>
<documentation>
<!-- $Id$ -->
<!--
	GridFlow Reference Manual: Class Reference
	Copyright (c) 2001,2002 by Mathieu Bouchard and Alexandre Castonguay
-->

<section name="Objects for making grids and breaking them down">

	<class name="@import">
		<icon text="[@import {240 320 3}]"/>
		<help text="[@import 240 320 3]" image="@importexport" />

		<p>This object allows you to import non-grid jMax data, such as
		integers and lists of integers. This object also reframes/resyncs
		integers and grids so that multiple grids may be joined together, or
		single grids may be split.</p>

		<method name="init">
			<arg name="dims" type="list(+integer)|symbol(per_message)">
			a list specifying a grid shape that the numbers
			will fit into; or "per_message" indicating each incoming message
			will be turned into a vector.
			</arg>
			<arg name="numbertype" type="numbertype">(default=int32)</arg>
		</method>
		<inlet id="0">
			<method name="int">
				begins a new grid if there is no current grid.
				puts that integer in the current grid.
				ends the grid if it is full.
				the constructed grid is not stored: it is streamed.
				the stream is buffered, so the output is in packets
				of about a thousand numbers.
			</method>
			<method name="list">
				just like a sequence of ints sent one after another,
				except in a single message.
			</method>
			<method name="symbol">
				considered as a list of ascii characters.
			</method>
			<method name="reset">
				aborts the current grid if there is one.
			</method>
			<method name="grid">
				<arg name="grid" type="grid(dims...)"/>
				this is the equivalent of filtering this grid through
				an @export object and sending the resulting integers
				to this @import object, except that it's over
				10 times faster.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid"><arg name="grid" type="grid(rank)"/>
				this grid is a dimension list that replaces the one
				specified in the constructor.
			</method>
			<method name="per_message">
				sets the per-message option described above.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>
				the grid produced from incoming integers and/or grids.
			</method>
		</outlet>
	</class>

	<class name="@export">
		<icon text="[@export]"/>
		<help text="[@export]" image="@importexport" />

		<p>this object is the opposite of @import.</p>
		<method name="init">
			this object is not configurable because there isn't
			anything that could possibly be configured here.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
				transforms this grid into a sequence of integer messages.
			</method>
		</inlet>
		<outlet id="0">
			<method name="int">
				elements of the incoming grid.
			</method>
		</outlet>
	</class>

	<class name="@export_list">
		<icon text="[@export_list]"/>
		<help text="[@export_list]" image="@importexport" />

		<p>this object is another opposite of @import, which puts
		all of its values in a jMax list.</p>
		<method name="init">
			this object is not configurable because there isn't
			anything that could possibly be configured here.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
				transforms this grid into a single message containing
				a list of integers.
			</method>
		</inlet>
		<outlet id="0">
			<method name="list">
				elements of the incoming grid.
			</method>
		</outlet>
	</class>

	<class name="@export_symbol">
		<p>this object is another opposite of @import, which puts
		all of its values in a jMax list.</p>
		<method name="init">
			this object is not configurable because there isn't
			anything that could possibly be configured here.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
				transforms this grid into a single message containing
				a list of integers.
			</method>
		</inlet>
		<outlet id="0">
			<method name="list">
				elements of the incoming grid.
			</method>
		</outlet>
	</class>

	<class name="@two">
		<icon text="[@two]"/>
		<help text="[@two]" image="@twothreefour"/>

		<p> holds two values, defaulting to (0,0). each time one is
		changed (by sending an integer in that inlet), a Dim(2) grid
		of those values is sent through the outlet.</p>
		<method name="init">no arguments.</method>
		<inlet id="0">
			<method name="int"/>
			<method name="bang">resend the grid without change</method>
		</inlet>
		<inlet id="1"><method name="int"/></inlet>
		<outlet id="0"><method name="grid"><arg name="grid" type="grid(2)"/></method></outlet>
	</class>

	<class name="@three">
		<icon text="[@three]"/>
		<help text="[@three]" image="@twothreefour"/>

		<p> holds three values, defaulting to (0,0,0). each time one is
		changed (by sending an integer in that inlet), a Dim(3) grid 
		of those values is sent through the outlet.</p>
		<method name="init">no arguments.</method>
		<inlet id="0">
			<method name="int"/>
			<method name="bang">resend the grid without change</method>
		</inlet>
		<inlet id="1"><method name="int"/></inlet>
		<inlet id="2"><method name="int"/></inlet>
		<outlet id="0"><method name="grid"><arg name="grid" type="grid(3)"/></method></outlet>
	</class>

	<class name="@four">
		<icon text="[@four]"/>
		<help text="[@four]" image="@twothreefour"/>

		<p> holds four values, defaulting to (0,0,0,0). each time one is
		changed (by sending an integer in that inlet), a Dim(4) grid
		of those values is sent through the outlet.</p>
		<method name="init">no arguments.</method>
		<inlet id="0">
			<method name="int"/>
			<method name="bang">resend the grid without change</method>
		</inlet>
		<inlet id="1"><method name="int"/></inlet>
		<inlet id="2"><method name="int"/></inlet>
		<inlet id="3"><method name="int"/></inlet>
		<outlet id="0"><method name="grid"><arg name="grid" type="grid(4)"/></method></outlet>
	</class>

	<class name="@for">
		<icon text="[@for 0 320 1]"/>
		<help text="[@for 0 320 1]"/>

		<p>when given scalar bounds, works like a regular [for] object plugged
		to a [@import] tuned for a Dim(size) where size is the number of values
		produced by a bang to that [for].</p>

		<p>when given vector bounds, will work like any number of [for] objects
		producing all possible combinations of their values in the proper order.
		This replaces the old [@identity_transform] object.</p>

		<method name="init">
			<arg name="from" type="integer"/>
			<arg name="to" type="integer"/>
			<arg name="step" type="integer"/>
		</method>
		<inlet id="0"><method name="grid"><arg name="grid" type="grid(index)"/>
			replaces the "from" value and produces output.
		</method></inlet>
		<inlet id="1"><method name="grid"><arg name="grid" type="grid(index)"/>
			replaces the "to" value.
		</method></inlet>
		<inlet id="2"><method name="grid"><arg name="grid" type="grid(index_steps)"/>
			replaces the "step" value.
		</method></inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid(size)"/>
				where size is floor((to-from+1)/step)
				[for scalar bounds]
			</method>
			<method name="grid"><arg name="grid" type="grid(*size,dimension)"/>
				where *size is floor((to-from+1)/step)
				[for vector bounds]
			</method>
		</outlet>
	</class>
</section>

<section name="Objects for Computing">
	<class name="@">
		<icon text="[@ +]" image="op/add.jpg" />
		<help text="two-input operators"/>
	
		<p>This object outputs a grid by computing "in parallel" a same
		operation on each left-hand element with its corresponding right-hand
		element. This is a massively parallel version of jMax's builtin
		arithmetic operators. In case you wonder, it's only parallel in the
		sense that all those computations are independent; there's no
		guarantee about how many of them will actually be computed at once.
		</p>

		<method name="init">
			<arg name="operator" type="symbol"/>
			<arg name="value" type="integer|grid"/>
			the operator is one picked in the table of the 30 two-input
			operators. the value (optional, zero by default) becomes
			the initial value of the right inlet. it may be a grid.
		</method>

		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
				on each element of this grid, perform the operation
				together with the corresponding element of inlet 1.
				in the table of operators (at the top of this document)
				elements of inlet 0 are called "A" and elements of inlet 1
				are called "B". the resulting grid is the same size as the
				one in inlet 0.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
				any grid, preferably shaped like the one that will be put
				in the left inlet, or like a subpart of it (the contents
				will be redim'ed on the fly to fit the grid of inlet-0,
				but the stored grid will not be modified itself)
			</method>
			<method name="int">
				stores a single int in the right inlet; the same int will
				be applied in all computations; this is like sending a
				Dim(1) or Dim() grid with that number in it.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>
			</method>
		</outlet>
	
	</class>

	<class name="@!">
		<icon text="[@!]"/>
		<help text="[@!]"/>

		<p>This object computes a grid by computing "in parallel" a same
		operation on each element of the grid.
		</p>
		
		<method name="init">
			<arg name="operator" type="symbol"/>
			the operator is one picked in the table of the 3 one-input
			operators.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>
			</method>
		</outlet>
	</class>

	<class name="@complex_sq">
		<p>this object computes the square of complex numbers.
		If seeing imaginary as Y and real as X, then this operation squares
		the distance of a point from origin and doubles the angle between it
		and the +X half-axis clockwise. (fun, eh?)
		</p>
		<p>used on an indexmap, this makes each thing appear twice,
		spanning half of the original angle.</p>
		<inlet id="0"><method name="grid">
			<arg name="grid" type="grid(dims... {imaginary real})"/>
		</method></inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(dims... {imaginary real})"/>
		</method></outlet>
	</class>

	<class name="@fold">
		<icon text="[@fold +]"/>
		<help text="[@fold +]" image="@foldinnerouter"/>

		<p><list>
		<li>[@fold +] computes totals</li>
		<li>[@fold inv+] is an alternated sum (+/-)</li>
		<li>[@fold * 1] can compute the size of a grid using its dimension list</li>
		<li>[@fold &amp; 1] can mean "for all"</li>
		<li>[@fold | 0] can mean "there exists (at least one)"</li>
		<li>[@fold ^ 0] can mean "there exists an odd number of..."</li>
		<li>[@fold ^ 1] can mean "there exists an even number of...".</li>
		</list></p>

		<method name="init">
			<arg name="operator" type="symbol"/>
			<arg name="base" type="integer"/>
			<arg name="right_hand" type="grid"/>
			the base value is optional and defaults to 0.
			the operator is one from the table of two-input operators.
		</method>
		
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims..., last)"/>
				replaces every Dim(last) subgrid by the result of a cascade on that subgrid.
				Doing that
				with base value 0 and operation + on grid "2 3 5 7" will compute
				((((0+2)+3)+5)+7) find the total "17".
				produces a Dim(dims) grid.
			</method>
		</inlet>
		<inlet id="1">
			<method name="int">
				changes the base value to use.
			</method>
		</inlet>
		<outlet id="0">
		</outlet>

	</class>

	<class name="@scan">
		<!-- <icon text="[@scan +]"/> -->
		<!-- <help text="[@scan +]"/> -->

		<p>[@scan +] computes subtotals; this can be used, for example,
		to convert a regular probability distribution into a cumulative one.
		</p>

		<method name="init">
			<arg name="operator" type="symbol"/>
			<arg name="base" type="integer"/>
			the base value is optional and defaults to 0.
			the operator is one from the table of two-input operators.
		</method>

		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims..., last)"/>

				replaces every Dim(last) subgrid by all the results of
				cascading the operator on that subgrid,
				producing a Dim(dims,last) grid.

				For example, with base value 0 and operation + on grid "2 3 5
				7" will compute 0+2=2, 2+3=5, 5+5=10, 10+7=17, and give the
				subtotals "2 5 10 17".

			</method>
		</inlet>
		<inlet id="1">
			<method name="int">
				changes the base value to use.
			</method>
		</inlet>
		<outlet id="0">
		</outlet>

	</class>

	<class name="@outer">
		<icon text="[@outer +]"/>
		<help text="[@outer +]" image="@foldinnerouter"/>

		<method name="init">
			<arg name="operator" type="symbol"/>
			<arg name="value" type="grid"/>
			the operator must be picked from the table of two-input operators.
			the grid is optional and corresponds to inlet 1.
		</method>

		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(anyA...)"/></method>
			produces a grid of size Dim(anyA..., anyB...), where numbers
			are the results of the operation on every element of A and
			every element of B. the resulting array can be very big. Don't
			try this on two pictures (the result will have 6 dimensions)
		</inlet>
		<inlet id="1">
			<method name="grid"><arg name="grid" type="grid(anyB...)"/></method>
			stores the specified grid, to be used when inlet 0 is activated.
		</inlet>
		<outlet id="0">
		</outlet>

		<p>When given a grid of Dim(3) and a grid of Dim(5) [@outer] will
		produce  a grid of Dim(3,5) with the selected two-input operation
		applied on each  of the possible pairs combinations between numbers
		from the left grid  and the ones from the right. for example :
		(10,20,30) [@outer +] (1,2,3)  will give :
		((11,12,13),(21,22,23),(31,32,33)) </p>

	</class>

	<class name="@inner,@inner2">
		<icon text="[@inner * + 0]"/>
		<help text="[@inner * + 0]" image="@foldinnerouter" />

		<p>think of this one as a special combination of [@outer], [@] and
		[@fold]. this is one of the most complex operations. It is very useful
		for performing linear transforms like rotations, scalings, shearings,
		and some kinds of color remappings. A linear transform is done by
		something called matrix multiplication, which happens to be [@inner * +
		0]. @inner also does dot product and other funny operations.</p>

		<p>@inner2 is a variant on @inner; used to be called @inner (GF-0.4.1
		and before); the right-hand "matrix" is transposed upon reception (the
		last dimension is swapped with the rest of the dimensions, so that the
		last becomes first and the others stay in order)</p>

		<method name="init">
			<arg name="op_para" type="symbol"/>
			<arg name="op_fold" type="symbol"/>
			<arg name="base"    type="integer"/>
			<arg name="right_hand" type="grid"/>
			op_para and op_fold are two operators picked from the table
			of two-input operators.
			the base value has to be specified (has no default value yet).
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(anyA..., lastA)"/>

				Splits the Dim(anyA...,lastA) left-hand grid into Dim(anyA...)
				pieces of Dim(lastA) size.

				Splits the Dim(firstB,anyB...) right-hand grid into
				Dim(anyB...) pieces of Dim(firstB) size.

				On every piece pair, does [@] using the specified
				op_para operation, followed by a [@fold] using
				the specified op_fold operator and base value.
			
				creates a Dim(anyA...,anyB...) grid by assembling all
				the results together.

				(note: lastA must be equal to firstB.)
			</method>
		</inlet>
		<inlet id="1">
			<method name="int">
				changes the base value to that.
			</method>
		</inlet>
		<inlet id="2">
			<method name="grid"><arg name="grid" type="grid(anyB..., lastB)"/>
				changes the right-hand side grid to that.
			</method>
		</inlet>
		<outlet id="0">
		</outlet>
	</class>

	<class name="@inner2">
		<icon text="[@inner2 * + 0]"/>
		<help text="[@inner2 * + 0]" image="@foldinnerouter" />

	</class>
	
	<class name="@join">
		<method name="init">
			<arg name="which_dim"/>

			Which_dim is the number of the dimension by which the join will
			occur. For N-dimensional grids, the dimensions are numbered from 0
			to N-1. In addition, negative numbers from -N to -1 may be used, to
			which N will be added.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>
				The left grid and right grid must have the same number
				of elements in all dimensions except the one specified.
				The result will have the same number of elements in all
				dimensions except the one specified, which will be the
				sum of the two corresponding one.
				
				<p>For example, joining a RGB picture Dim[y,x,3] and a
				greyscale picture Dim[y,x,1] on dimension 2 (or -1) could
				make a RGBA picture Dim[y,x,4] in which the greyscale image
				becomes the opacity channel.
				</p>
			</method>
		</inlet>
		<inlet id="1"><method name="grid"><arg name="grid" type="grid"/></method></inlet>
		<outlet id="0">
		</outlet>
	</class>

	<class name="@finished">
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>any grid</method>
		</inlet>
		<outlet id="0">
			a bang is emitted every time a grid transmission ends.
		</outlet>
	</class>

	<class name="@cast">
		<method name="init">
			<arg name="numbertype" type="numbertype"/>
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>any grid</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a grid of the same shape containing all the same
			values after type conversion. note that while casting to
			a smaller type, values that are overflowing will be truncated.
			</method>
		</outlet>
	</class>

	<class name="@ravel">
		<inlet id="0"><method name="grid"><arg name="grid" type="grid"/>any grid</method></inlet>
		<outlet id="0"><method name="grid"><arg name="grid" type="grid"/>
			like @redim but always produce a 1-D grid
			with the same total number of elements.
		</method></outlet>
	</class>

	<class name="@grade">
		<inlet id="0"><method name="grid"><arg name="grid" type="grid"/>any grid</method></inlet>
		<outlet id="0"><method name="grid"><arg name="grid" type="grid"/>
			<p>splits a Dim[A...,B] grid into Dim[B] vectors,
			producing new Dim[B] vectors that each contain numbers from
			0 to B-1 indicating the ordering of the values. The result is
			a Dim[A...,B] grid.</p>
			<p>for example, connecting a [@grade] to a [@outer ignore {0}]
			to a [@store] object, storing a single vector into [@store], and
			sending the same vector to [@grade], will sort the values of the
			vector. however for higher-dimensional grids, what should go
			between [@store] and [@grade] to achieve the same result would
			be more complex.</p>
			<p>you may achieve different kinds of sorting by applying various
			filters before [@grade]. the possibilities are unlimited.</p>
			<p>if you plug [@grade] directly into another [@grade], you will
			get the inverse arrangement, which allows to take the sorted values
			and make them unsorted in the original way. note that this is really
			not the same as just listing the values backwards.</p>
		</method></outlet>
	</class>

	<class name="perspective">
		<method name="init">
			<arg name="depth" type="integer"/>
		</method>
		<inlet id="0"><method name="grid"><arg name="grid" type="grid"/>any grid</method></inlet>
		<outlet id="0"><method name="grid"><arg name="grid" type="grid"/>
			<p>transforms a Dim[A...,B] grid into a Dim[A...,B-1] grid.
			There is a projection plane perpendicular to the last axis and
			whose position is given by the "depth" parameter. Each vector's
			length is adjusted so that it lies onto that plane. Then the
			last dimension of each vector is dropped.</p>
			
			<p>useful for converting from 3-D geometry to 2-D geometry. Also
			useful for converting homogeneous 3-D into regular 3-D, as
			homogeneous 3-D is really just regular 4-D...(!)</p>
		</method></outlet>
	</class>			
</section>

<section name="Objects for Coordinate Transforms">
	<class name="@redim">
		<icon text="[@redim {2}]"/>
		<help text="[@redim 2]"/>

		<method name="init">
			<arg name="dims" type="list(+integer)"/>
			a list specifying a grid shape that the numbers
			will fit into.
			(same as with @import)
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
			the elements of this grid are serialized. if the resulting grid
			must be larger, the sequence is repeated as much as necessary.
			if the resulting grid must be smaller, the sequence is truncated.
			then the elements are deserialized to form the resulting grid.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid"><arg name="grid" type="grid(rank)"/>
				this grid is a dimension list that replaces the one
				specified in the constructor.
				(same as with @import)
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>
				redimensioned grid potentially containing repeating data.
			</method>
		</outlet>

		<p>example: with a 240 320 RGB image, @redim 120 640 3 will visually
		separate the even lines (left) from the odd lines (right). contrary
		to this, @redim 640 120 3 will split every line and put its left half
		on a even line and the right half on the following odd line. @redim
		480 320 3 will repeat the input image twice in the output image.
		@redim 240 50 3 will only keep the 50 top lines.</p>

	</class>
	<class name="@store">
		<icon text="[@store]"/>
		<help text="[@store]"/>

		<p>A @store object can store exactly one grid, using the right
		inlet. You fetch it back, or selected subparts thereof, using the left
		inlet.</p>

		<method name="init">
			<arg name="number_type" type="int32 | uint8"/>
			The number type argument is optional and by default is int32,
			which allows the usual range of plus/minus two billions. With
			uint8, values are wrapped into the 0..255 interval, and stored
			in four times less memory.
		</method>

		<inlet id="0">
			<method name="bang">
				the stored grid is fully sent to the outlet.
			</method>
			<method name="grid"><arg name="grid" type="grid(dims..., indices)"/>
				in this grid, the last dimension refers to subparts of
				the stored grid. sending a Dim(200,200,2) on a @store
				that holds a Dim(240,320,3) will cause the @store to handle
				the incoming grid as a Dim(200,200) of Dim(2)'s, where each
				Dim(2) represents a position in a Dim(240,320) of Dim(3)'s.
				therefore the resulting grid will be a Dim(200,200) of
				Dim(3) which is a Dim(200,200,3). in practice this example
				would be used for generating a 200*200 RGB picture from a
				200*200 XY map and a 240*320 RGB picture. this object can
				be logically used in the same way for many purposes
				including color palettes, tables of probabilities, tables
				of statistics, whole animations, etc.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
				the received grid is stored. if the storage type is uint8,
				the input is filtered to fit 0..255.
			</method>
		</inlet>
		<outlet id="0">
			grids as stored, as indexed, or as assembled from multiple
			indexings.
		</outlet>
	</class>

	<class name="@identity_transform">
		<icon text="[@identity_transform]"/>
		<help text="[@identity_transform]"/>
		<p>
			OBSOLETE AND REMOVED. USE @for INSTEAD.
		</p>
	</class>

	<class name="@scale_to">
		<icon text="[@scale_to]"/>
		<help text="[@scale_to]"/>

		<method name="init">
			<arg name="size">{height width} pair.</arg>
		</method>

		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a 3-channel picture to be scaled.</method>
		</inlet>
		<inlet id="1">
			<method name="int">a {height width} pair.</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a scaled 3-channel picture.</method>
		</outlet>

		<p>@scale_to is normally fed the same inlet 1,2 values as
		@identity_transform, and chained from @identity_transform and to
		@store. This will scale an image of any size to the size specified
		in inlets 1,2. If it doesn't correspond the values of
		@identity_transform, part of the image will be trimmed and/or
		duplicated.</p>

	</class>

	<class name="@scale_by">
		<icon text="[@scale_by]"/>
		<help text="[@scale_by]"/>

		<method name="init">
			<arg name="factor" type="grid dim() or dim(2)"/>
			factor is optional (default is 2).
			if it's a single value, then that factor is to be used
			for both rows and columns.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(y x {r g b})"/>
			identical to @scale_to with arguments that are exactly
			twice those of the incoming grid. It is several times faster.
			</method>
		</inlet>
		<inlet id="1"><method name="grid"><arg name="grid" type="grid(1 or 2)"/>sets factor</method></inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid((factor*y) (factor*x) {r g b})"/>
			</method>
		</outlet>
	</class>

	<class name="@downscale_by">
		<method name="init">
			<arg name="factor" type="+integer"/>
			<arg name="how" type="optional symbol(smoothly)"/>
			factor is optional (default is 2).
			if it's a single value, then that factor is to be used
			for both rows and columns.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(y x {r g b})"/>
			Scales down picture by specified amount.
			</method>
		</inlet>
		<inlet id="1"><method name="grid">
			<arg name="grid" type="grid(1 or 2)"/>sets factor</method></inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid((factor/y) (factor/x) {r g b})"/>
		</method>
		</outlet>
	</class>

	<class name="@spread">
		<icon text="[@spread]"/>
		<help text="[@spread]"/>

		<p>typically you plug a @for into this object,
		and you plug this object into the left side of a @store. it will
		scatter pixels around, giving an "unpolished glass" effect.</p>
		
		<p>if you put a picture in it, however, it will add noise. The
		resulting values may be out of range, so you may need to clip them
		using min/max.</p>

		<method name="init">
			<arg name="factor">same as inlet 1</arg>
		</method>

		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a coordinate map.</method>
		</inlet>
		<inlet id="1">
			<method name="int">a spread factor.</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a coordinate map.</method>
		</outlet>


		<p>@spread scatters the pixels in an image. Not all original pixels
		will  appear, and some may get duplicated (triplicated, etc)
		randomly. Some  wrap-around effect will occur close to the edges.
		</p>

		<p> Sending an integer to inlet 1 sets the amount of spreading in
		maximum  number of pixels + 1. even values translate the whole image
		by half  a pixel due to rounding.</p>

	</class>

	<class name="@rotate">
		<p>performs rotations on indexmaps and polygons and such.</p>
		
		<method name="init">
			<arg name="angle" type="0...35999"/>
		</method>
		<inlet id="0"><method name="grid">
			<arg name="grid" type="grid(anyA 2)"/></method></inlet>
		<inlet id="1"><method name="int">rotation angle; 0...36000</method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(anyA 2)"/>
		</method></outlet>
	</class>

	<class name="@remap_image">
		<p>if you chain indexmap (coordinate) transformations from outlet 1
		to inlet 1, then sending an image in inlet 0 will emit its
		deformation out of outlet 0.</p>

		<inlet id="0"/>
		<inlet id="1"/>
		<outlet id="0"/>
		<outlet id="1"/>
	</class>
</section>

<section name="Objects for Reporting">
	<class name="@dim">
		<icon text="[@dim]"/>
		<help text="[@dim]"/>

		<p>Returns list of dimensions as a grid. Given a grid sized like Dim(240,320,4), 
		@dim will return a grid like Dim(3), whose values are 240, 320, 4. </p>

		<method name="init">
			no arguments.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
				ignores any data contained within.
				sends a grid dim(length of dims) containing dims.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid(rank)"/>
				the list of dimensions of the incoming grid.
			</method>
		</outlet>
	</class>

	<class name="@type">
		<p>gives a symbol representing the numeric type of the grid received.
		</p>
		<outlet id="0"><method type="numeric type symbol"/></outlet>
	</class>

	<class name="@print">
		<method name="init"/>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
			prints the dimensions of the grid.
			prints all the grid data if there are 2 dimensions or less.
			</method>
		</inlet>
	</class>

	<class name="rubyprint">
		This is only for testing the translation from PD/jMax to Ruby.
		<method name="init"/>
		<inlet id="0">
			<method name="&lt;any&gt;">
			prints the message to the console.
			</method>
		</inlet>
	</class>

	<class name="printargs">
		This is only for testing the translation from PD/jMax to Ruby.
		<method name="init">
			<rest name="any"/>
			prints everything.
		</method>
	</class>
</section>

<section name="Objects for Color Conversion">
	<class name="@apply_colormap_channelwise">
		<p>This object is useful for color correction. For each pixel
		it takes it apart, looks up each part separately in the colormap,
		and constructs a new pixel from that. You may also color-correct
		colormaps themselves.</p>

		<p>Only works for things that have 3 channels.</p>

		<p>Note: if you just need to apply a palette on an indexed-color
		picture, you don't need this. Just use @store instead.</p>
		
		<inlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns channels)"/>
			picture
		</method></inlet>
		<inlet id="1">
			<method name="grid">
			<arg name="grid" type="grid(intensities channels)"/>
			colormap ("palette")
		</method></inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns channels)"/>
			picture
		</method></outlet>
	</class>

	<class name="@rgb_to_greyscale">
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {red green blue})"/>
		</method></inlet>
		<outlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {white})"/></method>
		</outlet>
	</class>

	<class name="@greyscale_to_rgb">
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {white})"/></method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns {red green blue})"/>
		</method></outlet>
	</class>
</section>

<section name="Objects for Miscellaneous Picture Processing">
	<class name="@convolve">
		<icon text="[@convolve * + 0]"/>
		<help text="[@convolve * + 0]"/>

		<p>this is the object for blurring, sharpening, finding edges,
		embossing, and many other uses.</p>

		<method name="init">
			<arg name="op_para" type="symbol"/>
			<arg name="op_fold" type="symbol"/>
			<arg name="base"   type="integer"/>
			<arg name="right_hand" type="grid" default="none"/>
		</method>
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns rest...)"/>
				splits the incoming grid into dim(rest...) parts.
				for each of those parts at (y,x), a rectangle of such
				parts, centered around (y,x), is combined with the
				convolution grid like a [@] of operation op_para. Then
				each such result is folded like [@fold] of operation
				op_fold and specified base. the results are assembled
				into a grid that is sent to the outlet. near the borders of
				the grid, coordinates wrap around. this means the whole grid
				has to be received before production of the next grid
				starts.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid">
				<arg name="grid" type="grid(rows2 columns2)"/>
				this is the convolution grid and it gets stored in
				the object. rows2 and columns2 must be odd numbers.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns rest...)"/>
			</method>
		</outlet>
	</class>

	<class name="@contrast">
		<icon text="[@contrast]"/>
		<help text="[@contrast]"/> 

		<method name="init">
			<arg name="iwhiteness">same as inlet 1. default=256.</arg>
			<arg name="contrast">same as inlet 2. default=256.</arg>
		</method>
		
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/>
			produces a grid like the incoming grid but with
			different constrast.
			</method>
			<p>@contrast adjusts the intensity in an image.
			resulting values outside 0-255 are automatically clipped.</p>
		</inlet>
		<inlet id="1">
			<method name="int">
			this is the secondary contrast (inverse whiteness).
			it makes the incoming black
			correspond to a certain fraction between output black and the
			master contrast value. no effect is 256. default value is 256.
			</method>	
		</inlet>
		<inlet id="2">
			<method name="int">
			this is the master contrast. it makes the incoming white
			correspond to a certain fraction between output black and output
			white. no effect is 256. default value is 256.
			</method>	
		</inlet>
		<outlet>
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/>
			</method>
		</outlet>
	</class>

	<class name="@posterize">
		<icon text="[@posterize]"/>
		<help text="[@posterize]"/>

		<p>@posterize reduces the number of possible intensities in an image;
		it rounds the color values.The effect is mostly apparent with a low
		number of levels.</p>

		<method name="init">
			<arg name="levels">same as inlet 1</arg>
		</method>

		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/>
				produces a posterized picture from the input picture.
			</method>
		</inlet>

		<inlet id="1">
			<method name="int">
				this is the number of possible levels per channel. the
				levels are equally spaced, with the lowest at 0 and the
				highest at 255. the minimum number of levels is 2, and the
				default value is 2.
			</method>
		</inlet>
		
		<outlet id="0">
		</outlet>

		<p>example: simulate the 216-color "web" palette using 6 levels.
		simulate a 15-bit display using 32 levels.</p>
	</class>

	<class name="@solarize">
		<p>makes medium intensities brightest; formerly brightest colours
		become darkest; formerly darkest stays darkest. This filter is linear:
		it's like a 200% contrast except that overflows are <i>mirrored</i>
		instead of clipped or wrapped.</p>
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/></method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/></method>
		</outlet>
	</class>

	<class name="@checkers">
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {y x})"/>
				result from a [@for {0 0} {height width} {1 1}]
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				checkered pattern of 50%/75% greys
				in 8x8 squares
			</method>
		</outlet>
	</class>

	<class name="@layer">
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b a})"/>
				a picture that has an opacity channel.
				will be used as foreground.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				a picture that has NO opacity channel.
				will be used as background.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				a picture that has NO opacity channel.
				the opacity channel of the foreground is used as
				a weighting of how much of either picture is seen
				in the result.
			</method>
		</outlet>
	</class>

	<class name="@draw_polygon">
		<method name="init">
			<arg name="operator" type="symbol">
				Normally you would use the "put" operator here;
				but abnormally I recommend + and ^ for psychedelic effects.   
			</arg>
			<arg name="color" type="grid(channels)"/>
			<arg name="vertices" type="grid(vertices,{y x})"/>
		</method>
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x channels)"/>
				picture on which the polygon will be superimposed.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid"><arg name="grid" type="grid(channels)"/>
				color of each pixel
			</method>
		</inlet>
		<inlet id="2">
			<method name="grid">
				<arg name="grid" type="grid(vertices {y x})"/>
				vertices of the polygon.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x channels)"/>
				modified picture
			</method>
		</outlet>
	</class>

</section>

<section name="Special Objects">
	<class name="rtmetro">
		this is like jMax's builtin metro object. metro ensures that
		there is at least a given delay between bangs. rtmetro ensures
		that on average there is a given delay between bangs: it will
		compensate too long delays by shorter delays. of course this won't
		work if the system cannot keep up with the amount of work.

		<p>WARNING: this class does not work as advertised.</p>

		<method name="init"/>
		<method name="init geiger"/>
	</class>

	<class name="pingpong">
		send a value in inlet 1 first. if successive increasing values are
		sent in inlet 0, then output values will be successive increasing
		until they reach the right inlet value and then decrease to zero.

		the formula is stateless and so same inputs give always same output.
	</class>

	<class name="@global">
		<icon text="[@global]" />
		<help text="[@global]" />

		<p>
		objects of this class do nothing by themselves and are just
		an access point to features that don't belong to any object in
		particular.
		</p>
		<method name="profiler_reset">
			resets all the time counters.
		</method>
		<method name="profiler_dump">
			displays the time counters in decreasing order, with
			the names of the classes those objects are in. this is
			an experimental feature. like most statistics,
			it could be vaguely relied upon if
			only you knew to which extent it is unreliable. more on this
			in a future section called "profiling".
		</method>
	</class>

	<class name="fps">
		<method name="init">
			<arg name="clocktype" type="symbol(real|user|system|cpu)">
				which clock to use. "real" uses wallclock time. "user" uses
				the amount of time spent in the process. "system" uses the
				amount of time spent in the kernel on behalf of the process.
				"cpu" uses the Pentium clock, which is like a more precise
				version of "real" if you have a Pentium.
			</arg>
			<arg name="detailed" type="symbol(detailed)">optional</arg>
		</method>
		<method name="init detailed">
		</method>
		<inlet id="0">
			<method name="bang">
			Times at which bangs are received are stored until a large
			enough sample of those is accumulated. Large enough is defined
			to be whenever the timespan exceeds one second. Then a report
			is made through the outlet.
			</method>
			<method name="(else)">
				messages other than bangs are ignored.
			</method>
		</inlet>
		<outlet id="0">
			<method name="float">
			non-detailed mode only.
			this is the messages-per-second rating.
			</method>
			<method name="list(float,6)">
			detailed mode only.
			this is: messages-per-second, followed by five values of
			milliseconds-per-message: minimum, median, maximum, average,
			standard deviation.
			(the average happens to be simply 1000 divided by the
			messages-per-second, but it is convenient to have it anyway)
			</method>
		</outlet>
	</class>
</section>

<section name="jMax emulation">
	<p>those classes emulate jMax functionality,
	for use within PureData and Ruby.</p>

	<class name="fork">
		<p>Every incoming message is sent to inlet 1 and then sent to
		inlet 0 as well. Messages remain completely unaltered. Contrast
		with PureData's "t a a" objects, which have the same purpose but
		transform bangs into zeros and such.</p>

		<inlet id="0"><method name="&lt;any&gt;"/></inlet>
		<outlet id="0"/>
		<outlet id="1"/>
	</class>
	<class name="jmax_udpsend">
		Sends messages (but not grids nor dspsignals) via UDP (which
		does not involve a connection, and may lose packets in case of
		network overload or noise or etc)

		<method name="init">
			<arg name="host" type="host"/>
			<arg name="port" type="integer"/>
		</method>

		<inlet id="0"><method name="&lt;any&gt;"/></inlet>
	</class>
	<class name="jmax_udpreceive">
		<p>Counterpart of jmax_udpsend</p>

		<method name="init">
			<arg name="port" type="integer"/>
		</method>
		<outlet id="0"><method name="&lt;any&gt;"/></outlet>
		<outlet id="1"><method name="list">
			<arg name="protocol_name"/>
			<arg name="sender_port"/>
			<arg name="sender_host"/>
			<arg name="sender_ip_address"/>
		</method>
		</outlet>
	</class>
</section>

</documentation>
