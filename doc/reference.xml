	<class name="#perspective">
		<method name="init">
			<arg name="depth" type="integer"/>
		</method>
		<inlet id="0"><method name="grid"><arg name="grid" type="grid"/>any grid</method></inlet>
		<outlet id="0"><method name="grid"><arg name="grid" type="grid"/>
			transforms a Dim[A...,B] grid into a Dim[A...,B-1] grid.
			There is a projection plane perpendicular to the last axis and
			whose position is given by the "depth" parameter. Each vector's
			length is adjusted so that it lies onto that plane. Then the
			last dimension of each vector is dropped.
			
			useful for converting from 3-D geometry to 2-D geometry. Also
			useful for converting homogeneous 3-D into regular 3-D, as
			homogeneous 3-D is really just regular 4-D...(!)
		</method></outlet>
	</class>			

	<class name="#transpose">
		<method name="init">
			<arg name="dim1" type="integer"/>
			<arg name="dim2" type="integer"/>
		</method>
		<inlet id="0"><method name="grid"><arg name="grid" type="grid"/>
			swaps the two specified dimensions; dimension numbers are as in [#join].
		</method></inlet>
	</class>
	
	<class name="#fade">
		<method name="init">
			<arg name="rate" type="integer"/>
		</method>
		<inlet id="0"><method name="grid"><arg name="grid" type="grid"/>
			produces on outlet 0 a linear recurrent fading according to the flow of
			incoming messages. For example, if rate=5, then 20% (one fifth)
			of each new message will be blended with 80% of the previous output.
		</method></inlet>
	</class>

	<class name="#fade_lin">
		<method name="init">
			<arg name="maxraise" type="integer"/>
			<arg name="maxdrop"  type="integer"/>
		</method>
		<inlet id="0"><method name="grid"><arg name="grid" type="grid"/>
			produces on outlet 0 a piecewise-linear nonrecurrent fading according to the flow of
			incoming messages. For example, if maxraise=2 and maxdrop=4, then with each
			new message an output is produced that is at most 2 more or 4 less than the
			previous output.
		</method></inlet>
	</class>

	<class name="#reverse">
		<method name="init">
			<arg name="whichdim"/>
			Whichdim is the number of the dimension by which the reverse will
			occur. For N-dimensional grids, the dimensions are numbered from 0
			to N-1. In addition, negative numbers from -N to -1 may be used, to
			which N will be added.
		</method>
	</class>
	<class name="#redim">
		<method name="init">
			<arg name="dims" type="dim_list"/>
			a list specifying a grid shape that the numbers
			will fit into.
			(same as with [#import])
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
			the elements of this grid are serialized. if the resulting grid
			must be larger, the sequence is repeated as much as necessary.
			if the resulting grid must be smaller, the sequence is truncated.
			then the elements are deserialized to form the resulting grid.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid"><arg name="grid" type="grid(rank)"/>
				this grid is a dimension list that replaces the one
				specified in the constructor.
				(same as with [#import])
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>
				redimensioned grid potentially containing repeating data.
			</method>
		</outlet>

		example: with a 240 320 RGB image, [#redim 120 640 3] will visually
		separate the even lines (left) from the odd lines (right). contrary
		to this, [#redim 640 120 3] will split every line and put its left half
		on a even line and the right half on the following odd line. [#redim]
		480 320 3 will repeat the input image twice in the output image.
		[#redim] 240 50 3 will only keep the 50 top lines.

	</class>
	<class name="#store">
		A [#store] object can store exactly one grid, using the right
		inlet. You fetch it back, or selected subparts thereof, using the left
		inlet.

		<method name="init">
			<arg name="contents" type="grid"/>
		</method>

		<inlet id="0">
			<method name="bang">
				the stored grid is fully sent to the outlet.
			</method>
			<method name="grid"><arg name="grid" type="grid(dims..., indices)"/>
				in this grid, the last dimension refers to subparts of
				the stored grid. sending a Dim(200,200,2) on a [#store]
				that holds a Dim(240,320,3) will cause the [#store] to handle
				the incoming grid as a Dim(200,200) of Dim(2)'s, where each
				Dim(2) represents a position in a Dim(240,320) of Dim(3)'s.
				therefore the resulting grid will be a Dim(200,200) of
				Dim(3) which is a Dim(200,200,3). in practice this example
				would be used for generating a 200*200 RGB picture from a
				200*200 XY map and a 240*320 RGB picture. this object can
				be logically used in the same way for many purposes
				including color palettes, tables of probabilities, tables
				of statistics, whole animations, etc.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
			replace the whole grid, or a subpart of it (see other options on inlet 1)
			</method>
		</inlet>
		<inlet id="1">
			<method name="reassign">(Future Use): 
				makes it so that sending a grid to inlet 1 detaches the old buffer from [#store]
				and attaches a new one instead.  This is the default.
			</method>
			<method name="put_at"><rest name="indices"/>(Future Use): 
				makes it so that sending a grid to inlet 1 writes into the existing buffer of [#store].
				
				example: suppose you have [#store {10 240 320 3}]. then "put_at 3"
				will allow to write a Dim[240,320,3] grid in indices (3,y,x,c) where y,x,c are indices of the incoming grid;
				in other words, if that's a buffer of 10 RGB frames, you'd be replacing frame #3. Furthermore,
				it also allows you to write a Dim[n,240,320,3] grid at (3+f,y,x,c) where f,y,x,c are indices of the incoming grid,
				replacing frame #3, #4, ... up to #3+n-1. Here n is at most 7 because the last frame in the buffer is #9.
				
				that way of working extends to other kinds of data you'd put in Grids, in any numbers of dimensions;
				because, as usual, [#store] wouldn't know the difference.
				
			</method>
		</inlet>
		<outlet id="0">
			grids as stored, as indexed, or as assembled from multiple
			indexings.
		</outlet>
	</class>

	<class name="#scale_to">
		<method name="init">
			<arg name="size">{height width} pair.</arg>
		</method>

		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a 3-channel picture to be scaled.</method>
		</inlet>
		<inlet id="1">
			<method name="int">a {height width} pair.</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a scaled 3-channel picture.</method>
		</outlet>
	</class>

	<class name="#scale_by">
		<method name="init">
			<arg name="factor" type="grid dim() or dim(2)"/>
			factor is optional (default is 2).
			if it's a single value, then that factor is to be used
			for both rows and columns.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(y x channels)"/>
			duplicates each pixel several times in width and several times in height,
			where the number of times is determined by the factor described above.
			twice those of the incoming grid. It is several times faster.
			</method>
		</inlet>
		<inlet id="1"><method name="grid"><arg name="grid" type="grid(1 or 2)"/>sets factor</method></inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid((factor*y) (factor*x) channels)"/>
			</method>
		</outlet>
	</class>

	<class name="#downscale_by">
		<method name="init">
			<arg name="factor" type="+integer"/>
			<arg name="how" type="optional symbol(smoothly)"/>
			factor is optional (default is 2).
			if it's a single value, then that factor is to be used
			for both rows and columns.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(y x channels)"/>
			Scales down picture by specified amount. (See scale factor above)
			</method>
		</inlet>
		<inlet id="1"><method name="grid">
			<arg name="grid" type="grid(1 or 2)"/>sets scale factor</method></inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid((factor/y) (factor/x) channels)"/>
		</method>
		</outlet>
	</class>

	<class name="#spread">
		typically you plug a [#for] into this object,
		and you plug this object into the left side of a [#store]. it will
		scatter pixels around, giving an "unpolished glass" effect.
		
		if you put a picture in it, however, it will add noise. The
		resulting values may be out of range, so you may need to clip them
		using min/max.

		<method name="init">
			<arg name="factor">same as inlet 1</arg>
		</method>

		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a coordinate map.</method>
		</inlet>
		<inlet id="1">
			<method name="int">a spread factor.</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid"/>a coordinate map.</method>
		</outlet>


		[#spread] scatters the pixels in an image. Not all original pixels
		will  appear, and some may get duplicated (triplicated, etc)
		randomly. Some  wrap-around effect will occur close to the edges.
		

		 Sending an integer to inlet 1 sets the amount of spreading in
		maximum  number of pixels + 1. even values translate the whole image
		by half  a pixel due to rounding.

	</class>

	<class name="#rotate">
		performs rotations on indexmaps and polygons and such.
		
		<method name="init">
			<arg name="angle" type="0...35999"/>
		</method>
		<inlet id="0"><method name="grid">
			<arg name="grid" type="grid(anyA 2)"/></method></inlet>
		<inlet id="1"><method name="int">rotation angle; 0...36000</method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(anyA 2)"/>
		</method></outlet>
	</class>

	<class name="#remap_image">
		if you chain indexmap (coordinate) transformations from outlet 1
		to inlet 1, then sending an image in inlet 0 will emit its
		deformation out of outlet 0.

		<inlet id="0"/>
		<inlet id="1"/>
		<outlet id="0"/>
		<outlet id="1"/>
	</class>
	<class name="#dim">
		Returns list of dimensions as a grid. Given a grid sized like Dim(240,320,4), 
		[#dim] will return a grid like Dim(3), whose values are 240, 320, 4. 

		<method name="init">
			no arguments.
		</method>
		<inlet id="0">
			<method name="grid"><arg name="grid" type="grid(dims...)"/>
				ignores any data contained within.
				sends a grid dim(length of dims) containing dims.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid"><arg name="grid" type="grid(rank)"/>
				the list of dimensions of the incoming grid.
			</method>
		</outlet>
	</class>

	<class name="#type">
		gives a symbol representing the numeric type of the grid received.
		
		<outlet id="0"><method name="&lt;numeric type symbol&gt;"/></outlet>
	</class>

	<class name="display">
		GUI object equivalent to [print] and [#print].
		<method name="(any)">
		Displays the received message in the box, resizing the box so that the message fits exactly.
		</method>
	</class>
	<class name="#apply_colormap_channelwise">
		This object is useful for color correction. For each pixel
		it takes it apart, looks up each part separately in the colormap,
		and constructs a new pixel from that. You may also color-correct
		colormaps themselves.

		Only works for things that have 3 channels.

		Note: if you just need to apply a palette on an indexed-color
		picture, you don't need this. Just use #store instead.
		
		<inlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns channels)"/>
			picture
		</method></inlet>
		<inlet id="1">
			<method name="grid">
			<arg name="grid" type="grid(intensities channels)"/>
			colormap ("palette")
		</method></inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns channels)"/>
			picture
		</method></outlet>
	</class>

	<class name="#rgb_to_greyscale">
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {red green blue})"/>
		</method></inlet>
		<outlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {white})"/></method>
		</outlet>
	</class>

	<class name="#greyscale_to_rgb">
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {white})"/></method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns {red green blue})"/>
		</method></outlet>
	</class>

	<class name="#yuv_to_rgb">
		note: may change slightly to adapt to actual video standards.
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {y u v})"/></method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns {red green blue})"/>
		</method></outlet>
	</class>

	<class name="#rgb_to_yuv">
		note: may change slightly to adapt to actual video standards.
		<inlet id="0"><method name="grid">
		<arg name="grid" type="grid(rows columns {red green blue})"/></method>
		</inlet>
		<outlet id="0"><method name="grid">
			<arg name="grid" type="grid(rows columns {y u v})"/>
		</method></outlet>
	</class>
	<class name="#convolve">
		this is the object for blurring, sharpening, finding edges,
		embossing, cellular automata, and many other uses.
<!--NYI
		<attr name="seed">
		
		</attr>
-->
		<method name="init">
			<arg name="op_para" type="numop2"/>
			<arg name="op_fold" type="numop2"/>
			<arg name="seed"   type="grid"/>
			<arg name="right_hand" type="grid" default="none"/>
		</method>
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns rest...)"/>
				splits the incoming grid into dim(rest...) parts.
				for each of those parts at (y,x), a rectangle of such
				parts, centered around (y,x), is combined with the
				convolution grid like a [#] of operation op_para. Then
				each such result is folded like [#fold] of operation
				op_fold and specified base. the results are assembled
				into a grid that is sent to the outlet. near the borders of
				the grid, coordinates wrap around. this means the whole grid
				has to be received before production of the next grid
				starts.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid">
				<arg name="grid" type="grid(rows2 columns2)"/>
				this is the convolution grid and it gets stored in
				the object. if rows2 and/or columns2 are odd numbers,
				then the centre of convolution is the middle of the convolution
				grid. if they are even numbers, then the chosen centre will
				be slightly more to the left and/or to the top, because the
				actual middle is between cells of the grid.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns rest...)"/>
			</method>
		</outlet>
	</class>

	<class name="#contrast">
		<method name="init">
			<arg name="iwhiteness" default="256">same as inlet 1.</arg>
			<arg name="contrast" default="256">same as inlet 2.</arg>
		</method>

		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/>
			produces a grid like the incoming grid but with
			different constrast.
			</method>
			[#contrast] adjusts the intensity in an image.
			resulting values outside 0-255 are automatically clipped.
		</inlet>
		<inlet id="1">
			<method name="int">
			this is the secondary contrast (inverse whiteness).
			it makes the incoming black
			correspond to a certain fraction between output black and the
			master contrast value. no effect is 256. default value is 256.
			</method>	
		</inlet>
		<inlet id="2">
			<method name="int">
			this is the master contrast. it makes the incoming white
			correspond to a certain fraction between output black and output
			white. no effect is 256. default value is 256.
			</method>	
		</inlet>
		<outlet>
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/>
			</method>
		</outlet>
	</class>

	<class name="#posterize">
		[#posterize] reduces the number of possible intensities in an image;
		it rounds the color values.The effect is mostly apparent with a low
		number of levels.

		<method name="init">
			<arg name="levels">same as inlet 1</arg>
		</method>

		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/>
				produces a posterized picture from the input picture.
			</method>
		</inlet>

		<inlet id="1">
			<method name="int">
				this is the number of possible levels per channel. the
				levels are equally spaced, with the lowest at 0 and the
				highest at 255. the minimum number of levels is 2, and the
				default value is 2.
			</method>
		</inlet>
		
		<outlet id="0">
		</outlet>

		example: simulate the 216-color "web" palette using 6 levels.
		simulate a 15-bit display using 32 levels.
	</class>

	<class name="#solarize">
		makes medium intensities brightest; formerly brightest colours
		become darkest; formerly darkest stays darkest. This filter is linear:
		it's like a 200% contrast except that overflows are <i>mirrored</i>
		instead of clipped or wrapped.
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/></method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(rows columns channels)"/></method>
		</outlet>
	</class>

	<class name="#checkers">
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {y x})"/>
				result from a [#for {0 0} {height width} {1 1}]
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				checkered pattern of 50%/75% greys
				in 8x8 squares
			</method>
		</outlet>
	</class>

	<class name="#layer">
		<inlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b a})"/>
				a picture that has an opacity channel.
				will be used as foreground.
			</method>
		</inlet>
		<inlet id="1">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				a picture that has NO opacity channel.
				will be used as background.
			</method>
		</inlet>
		<outlet id="0">
			<method name="grid">
				<arg name="grid" type="grid(y x {r g b})"/>
				a picture that has NO opacity channel.
				the opacity channel of the foreground is used as
				a weighting of how much of either picture is seen
				in the result.
			</method>
		</outlet>
	</class>

	<class name="#text_to_image">
		inlet 2 receives a font grid, for example, [#in grid file lucida-typewriter-12.grid.gz]
		inlet 1 receives a 2 by 3 matrix representing the colours to use (e.g. (2 3 # 0 170 0 255 255 0) means yellow on green)
		inlet 0 receives a bang, transforming the data into an image suitable for #draw_image.
	</class>
	<class name="#hueshift">
		inlet 1 receives an angle (0..36000)
		inlet 0 receives a RGB picture that gets hueshifted by a rotation in the colorwheel by the specified angle; it gets sent to outlet 0.
	</class>
	<class name="pingpong">
		Transforms linear counting (0, 1, 2, 3, 4, ...)  into a back-and-forth counting (0, 1, 2, 1, 0, ...)
		from 0 to a specified upper bound.
		<method name="init">
			<arg name="top" type="int"/>
		</method>
		<inlet id="1">
			<method name="float"><arg name="top" type="float"/></method>
		</inlet>
		<inlet id="0">
			<method name="float">
				a value to be transformed.
				If, for example, top=10, then values 0 thru 10 are left unchanged,
				values 11 thru 19 are mapped to 9 thru 1 respectively, and 20 thru 30
				are mapped to 0 thru 10, and so on.
			</method>
		</inlet>
	</class>
	<class name="fps">
		<method name="init">
			<arg name="clocktype" type="symbol(real|user|system|cpu)">
				which clock to use. "real" uses wallclock time. "user" uses
				the amount of time spent in the process. "system" uses the
				amount of time spent in the kernel on behalf of the process.
				"cpu" uses the Pentium clock, which is like a more precise
				version of "real" if you have a Pentium.
			</arg>
			<arg name="detailed" type="symbol(detailed)">optional</arg>
		</method>
		<method name="init detailed">
		</method>
		<inlet id="0">
			<method name="bang">
			Times at which bangs are received are stored until a large
			enough sample of those is accumulated. Large enough is defined
			to be whenever the timespan exceeds one second. Then a report
			is made through the outlet.
			</method>
			<method name="(else)">
				messages other than bangs are ignored.
			</method>
		</inlet>
		<outlet id="0">
			<method name="float">
			non-detailed mode only.
			this is the messages-per-second rating.
			</method>
			<method name="list(float,6)">
			detailed mode only.
			this is: messages-per-second, followed by five values of
			milliseconds-per-message: minimum, median, maximum, average,
			standard deviation.
			(the average happens to be simply 1000 divided by the
			messages-per-second, but it is convenient to have it anyway)
			</method>
		</outlet>
	</class>
	<class name="fork">
		Every incoming message is sent to inlet 1 and then sent to
		inlet 0 as well. Messages remain completely unaltered. Contrast
		with PureData's "t a a" objects, which have the same purpose but
		transform bangs into zeros and such.

		<inlet id="0"><method name="(any)"/></inlet>
		<outlet id="0"/>
		<outlet id="1"/>
	</class>
	<class name="foreach">
		<inlet id="0"><method name="list"><rest/>
			Outputs N messages, one per list element, in order.
		</method></inlet>
	</class>
	<class name="listreverse">
		<inlet id="0"><method name="list"><rest/>
			Outputs the incoming list, from last element to first element.
		</method></inlet>
	</class>
	<class name="messageprepend">
		(This is not in jMax, but is there to help port $* messageboxes)
		<method name="init"><rest name="list" isattr="yes"/></method>
		<inlet id="0"><method name="&lt;any&gt;"><rest/>
			Like [listprepend], but operates on whole messages, that is, including the selector.
		</method></inlet>
		<inlet id="1" attr="list"/>
	</class>
	<class name="messageappend">
		(This is not in jMax, but is there to help port $* messageboxes)
		<method name="init"><rest name="list" isattr="yes"/></method>
		<inlet id="0"><method name="&lt;any&gt;"><rest/>
			Like [listappend], but operates on whole messages, that is, including the selector.
		</method>
		</inlet>
		<inlet id="1" attr="list"/>
	</class>
	<class name="range">
		<method name="init">
			<rest name="separators" type="float"></rest>
		</method>
		<inlet id="0"><method name="float">
			a value to be sent to one of the outlets. The first outlet is for values
			smaller than the first argument; else the second outlet is for values smaller
			than the second argument; and so on; and the last outlet is for values greater
			or equal to the last argument.
		</method></inlet>
		<inlet id="1..n"><method name="float">
			sets the corresponding separator in the separator list.
		</method></inlet>
	</class>
	<class name="#centroid">
		<method name="init"/>
		<inlet id="0"><method name="grid(rows,columns,1)">
			will compute the centroid of the given grid, which
			is a weighted average, namely, the average position weighted
			by the pixel values.
		</method></inlet>
		<outlet id="0">
			<method name="grid(2)">
			result
			</method>
		</outlet>
	</class>
