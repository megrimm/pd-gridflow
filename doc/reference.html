<html>
<head>
<title>GridFlow 0.4.0 - reference</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="jmax.css" type="text/css">
</head>
<body
  bgcolor="#FFFFFF"
  leftmargin="0"
  topmargin="0"
  marginwidth="0"
  marginheight="0">
<table
  width="100%"
  bgcolor="white"
  border="0"
  cellspacing="2">
<tr> 
<td colspan="4" bgcolor="#082069">
<img src="images/jmax_titre.jpg" width="253" height="23"></td>
</tr>
<tr> 
<td>&nbsp;</td>
</tr>
<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4" height="16"> 
    <h4>GridFlow 0.4.0 - reference index</h4>
</td></tr>
<tr> 
  <td width="5%" rowspan="2">&nbsp;</td>
  <td width="25%" height="23">&nbsp;</td>
  <td width="66%" height="23">&nbsp;</td>
  <td width="5%"  height="23">&nbsp;</td>
</tr>
<tr><td colspan='2'>
<h5><a href="Conventions of this Manual">Conventions of this Manual</a></h5><blockquote></blockquote><h5><a href="Grid Protocol">Grid Protocol</a></h5><blockquote></blockquote><h5><a href="Picture Protocol">Picture Protocol</a></h5><blockquote></blockquote><h5><a href="Objects for Input/Output">Objects for Input/Output</a></h5><blockquote><img src="images/video_in_file.jpg" alt="[@ import 240 320 3]"><br><img src="images/out.jpg" alt="[@out]"><br><img src="images/@import_240_320_3.jpg" alt="[@ import 240 320 3]"><br><img src="images/@export.jpg" alt="[@export]"><br></blockquote><h5><a href="Transformation Objects">Transformation Objects</a></h5><blockquote><img src="images/@fold_%2B.jpg" alt="[@fold +]"><br><img src="images/@redim.jpg" alt="[@redim 2]"><br><img src="images/@store.jpg" alt="[@store]"><br><img src="images/@outer.jpg" alt="[@outer +]"><br></blockquote><h5><a href="Reporting Objects">Reporting Objects</a></h5><blockquote><img src="images/@dim.jpg" alt="[@dim]"><br></blockquote><h5><a href="Special Objects">Special Objects</a></h5><blockquote></blockquote><h5><a href="Compound Objects">Compound Objects</a></h5><blockquote><img src="images/@contrast.jpg" alt="[@contrast]"><br><img src="images/@identity_transform.jpg" alt="[@identity_transform]"><br><img src="images/@posterize.jpg" alt="[@posterize]"><br><img src="images/@scale_to.jpg" alt="[@scale_to]"><br><img src="images/@spread.jpg" alt="[@spread]"><br><img src="images/@three.jpg" alt="[@three]"><br><img src="images/@two.jpg" alt="[@two]"><br></blockquote><h5><a href="Unary Operators">Unary Operators</a></h5><blockquote></blockquote><h5><a href="Binary Operators">Binary Operators</a></h5><blockquote></blockquote><h5><a href="External Picture Formats">External Picture Formats</a></h5><blockquote><img src="images/open_ppm.jpg" alt="[open filename.ppm]"><br><img src="images/open_tga.jpg" alt="[open filename.tga targa]"><br><img src="images/open_videodev.jpg" alt="[open /dev/video0 videodev]"><br><img src="" alt="[open x11 here]"><br></blockquote><br><br></td></tr>








<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><h4>Conventions of this Manual</h4></td></tr>

<tr><td></td><td></td><td>

	(In this section, usage of Bold, Italic, Courier, etc. would be explained.

	eventually I'd like those to have precise meanings consistent throughout

	the whole documentation)

</td></tr>

<tr><td>&nbsp;</td></tr>



<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><h4>Grid Protocol</h4></td></tr>

<tr><td></td><td></td><td>

	<p><i>This section is useful is you want to do more than just pictures

	with GridFlow.

	</i></p>

	<p>

	each element of a grid is an integer. the range of allowed integer values 

	is called <i>signed 32-bit</i> and is -2147483648 to 2147483647 (which 

	is -2<sup>31</sup> to 2<sup>31</sup>-1).

	</p>

	<p>

	a single-dimensional grid of 3 elements (a triplet) is called dim(3). a

	three-dimensional grid of 240 rows of 320 columns of triplets is called

	dim(240,320,3).

	</p>

	<p>

	There is a sequence in which elements of a Grid are stored and

	transmitted.  Dimension 0 is called "outer" or "first" and dimension N-1 is

	called  "inner" or "last". They are called so because if you select a

	position in the first dimension of a grid, the selected part is of the same

	shape minus the first dimension; so in dim(240,320,3) if you select

	row 51 (or whichever valid row number), you get a dim(320,3). if you select

	a subpart two more times you get to a single number.

	</p>

	<p>

	At each such level, elements are sent/stored in their numeric order, 

	and are numbered using natural numbers starting at 0. This ordering usually 

	does not matter, but sometimes it does. Most notably, <kbd>@import</kbd>, 

	<kbd>@export</kbd> and <kbd>@redim</kbd> care about it. 

	</p>

	<p>

	On the other hand, order of dimensions usually does matter; this is 

	what distinguishes rows from columns and channels, for example.

	Most objects care about the distinction.

	</p>

	<p>

	A grid with only 1 element in a given dimension is different from one

	lacking that dimension; it won't have the same meaning. You can use this

	property to your advantage sometimes.

	</p>

	<p>

	Zero-dimensional grids exist. They are called dim(). They can only contain

	a single number.

	</p>

</td></tr>

<tr><td>&nbsp;</td></tr>



<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><h4>Picture Protocol</h4></td></tr>

<tr><td></td><td></td><td>

	<p><i>This section is useful if you want to know what a picture is

	in terms of a grid.

	</i></p>



	<p>A picture is a three-dimensional Grid: 

	<ul>

		<li><b>0</b> : rows</li>

		<li><b>1</b> : columns</li>

		<li><b>2</b> : channels</li>

	</ul>

	</p>

	<p>Channels for the RGB color model are:

	<ul>

		<li><b>0</b> : red</li>

		<li><b>1</b> : green</li>

		<li><b>2</b> : blue</li>

	</ul>

	</p>

	<p>

	Because Grids are made of 32-bit integers, a three-channel picture uses 

	96 bpp (bits per pixel), and have to be downscaled to 24 bpp (or 16 bpp) 

	for display. That huge amount of slack is there because when you create 

	your own effects you often have intermediate results that need to be of 

	higher precision than a normal picture. Especially, results of multiplications 

	are big and should not overflow before you divide them back to normal; 

	and similarly, you can have negative values all over, as long as you take 

	care of them before they get to the display.

	</p>

	<p>

	In the final conversion, high bits are just ignored. This means: black is

	0, maximum is 255, and values wrap like with <kbd>% 256</kbd>. If you want to

	clip them, you may use <kbd>"@ max 0"</kbd> and <kbd>"@ min 255"</kbd> objects. 

	</p>

</td></tr>

<tr><td>&nbsp;</td></tr>



<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><h4>Objects for Input/Output</h4></td></tr>

	<tr><td colspan="4"><h5><a name="@in">@in</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/video_in_file.jpg"><br clear="left"><br><br><a href="images/grab_video_in.png"><img src="images/ic_grab_video_in.jpg" border="0"></a></td><td>

		



		<br><b>method</b> init <b>(</b><b>)</b>

			Creates an input object for an unspecified format. You

			need to use the <kbd>open</kbd> command to decide that.



			Remember that most formats produce dim(rows,columns,3) grids with

			0-255 values. (Most.)

		<br><br>



		

			<br><b>inlet 0</b> <b>method</b> open <b>(</b>format<b>,</b> ... format_specific_part<b>)</b>

				

				

				This is the command that gives a particular resource

				to a @out object. This is done through a "format"

				(there is a list of formats in this manual). The other

				arguments depend on the chosen format. The format may

				be a file format or a protocol or a hardware device, etc.

			<br><br>

			<br><b>inlet 0</b> <b>method</b> close <b>(</b><b>)</b>

				close may be necessary if you operate on "/dev/video",

				which can only be read by one at a time. otherwise it's

				usually not necessary.

			<br><br>

			<br><b>inlet 0</b> <b>method</b> bang <b>(</b><b>)</b>

				sends a grid through the outlet. the grid may be the

				result of reading from a file, acquiring from a device,

				capturing from the screen etc.



				this is format-specific. most formats

				produce <b>dim(</b>rows columns {red green blue}<b>)</b>.



				In formats that read from a file, reading another picture

				will continue if several pictures are concatenated in the

				file, but if the end of file is reached instead, it will

				rewind and send the first picture again.



				see section "External Picture Formats".



			<br><br>

			<br><b>inlet 0</b> <b>method</b> option <b>(</b>selector<b>,</b> ... stuff<b>)</b>

				

				

				for format-specific options.

				(usually in devices that masquerade as formats).



				see section "External Picture Formats".

			<br><br>

		

		

	

	<tr><td colspan="4"><h5><a name="@out">@out</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/out.jpg"><br clear="left"><br><br><a href="images/grab_video_out_file.png"><img src="images/ic_grab_video_out_file.jpg" border="0"></a></td><td>

		

		<br><b>method</b> init <b>(</b><b>)</b>

			Creates an output object for an unspecified format. You

			need to use the <kbd>open</kbd> command to decide that.



			Remember that most formats expect dim(rows,columns,3) grids with

			0-255 values. (Most.)

		<br><br>

		<br><b>method</b> init <b>(</b>rows<b>,</b>columns<b>)</b>

			

			



			This alternate way to create an @out automatically calls

			"open x11 here" and "option out_size <i>rows columns</i>".

		<br><br>

		

			<br><b>inlet 0</b> <b>method</b> open <b>(</b>format<b>,</b> ... format_specific_part<b>)</b>

				

				

				This is the command that gives a particular resource

				to a @out object. This is done through a "format"

				(there is a list of formats in this manual). The other

				arguments depend on the chosen format. The format may

				be a file format or a protocol or a hardware device, etc.

			<br><br>

			<br><b>grid</b> 

				this is format-specific. most formats

				expect <b>dim(</b>rows columns {red green blue}<b>)</b>.



				In formats that write to a file, sending a 2nd picture

				overwrites the first.



				see section "External Picture Formats".

			<br><br>

			<br><b>inlet 0</b> <b>method</b> close <b>(</b><b>)</b>

				closes the file. usually not necessary.

			<br><br>

			<br><b>inlet 0</b> <b>method</b> option <b>(</b>selector<b>,</b> ... stuff<b>)</b>

				

				

				for format-specific options.

				(usually in devices that masquerade as formats).



				see section "External Picture Formats".

			<br><br>

			<br><b>inlet 0</b> <b>method</b> option timelog <b>(</b>status<b>)</b>

				

				when status=1, current time (unix clock) and time since last

				frame-end are printed in the console. when status=0, it is off.

				default is 0.

			<br><br>



		

		

			<br><b>outlet 0</b> <b>method</b> bang <b>(</b><b>)</b>

				sent when a complete grid has been received.

			<br><br>

		

		

	

	<tr><td colspan="4"><h5><a name="@import">@import</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@import_240_320_3.jpg"><br clear="left"><br><br><a href="images/grab_import.png"><img src="images/ic_grab_import.jpg" border="0"></a></td><td>

		

		<p>Objects of this class have an inlet that can receive integers and reset 

as well as Grid outlet. You specify the dimensions (all of them) in the 

constructor. For a 240-row 320-column picture you'd say: @import 240 320 

3 </p>

<p>An import object accumulates the integers you send to it. They should 

be in the 0-255 range. When you send 3 of them, they represent the red, 

green and blue values of one pixel. Successive pixels are ordered left 

to right and when there are enough of them they form a line. Successive 

lines are ordered top to bottom and when there are enough of them they 

form a frame. After a frame is completed a new frame begins replacing 

the previous one.</p>



		

			<br><b>inlet 0</b> <b>method</b> int <b>(</b><b>)</b>

				begins a new grid if there is no current grid.

				puts that integer in the current grid.

				ends the grid if it is full.

			<br><br>

			<br><b>inlet 0</b> <b>method</b> reset <b>(</b><b>)</b>

				aborts the current grid if there is one.

			<br><br>

		

		

	

	<tr><td colspan="4"><h5><a name="@export">@export</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@export.jpg"><br clear="left"><br><br><a href="images/grab_export.png"><img src="images/ic_grab_export.jpg" border="0"></a></td><td>

		

<p>Objects of this class have a Grid inlet and a 0.1-compatible outlet. 

They do the opposite of @import and take no parameters. </p>

		



		

		

	

<tr><td>&nbsp;</td></tr>



<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><h4>Transformation Objects</h4></td></tr>

	<tr><td colspan="4"><h5><a name="@fold">@fold</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@fold_%2B.jpg"><br clear="left"><br><br><a href="images/grab_fold.png"><img src="images/ic_grab_fold.jpg" border="0"></a></td><td>

		

		<p>



		@fold makes the last dimension of a grid disappear by combining elements

		together in each innermost array. For example, @fold + 0 on a RGB image

		will output a channelless image in which every value is the sum of

		red/green/blue values in a pixel. The zero is the starting value, so that

		is actually 0+r+g+b. You can get the number of values in a grid by passing

		it through @dim and then through @fold * 1.

		</p>



		

	

	<tr><td colspan="4"><h5><a name="@redim">@redim</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@redim.jpg"><br clear="left"><br><br><a href="images/grab_redim.png"><img src="images/ic_grab_redim.jpg" border="0"></a></td><td>

		



		<p> @redim outputs a grid of the dimensions provided in the

constructor,  based on serializing the input grid and reserializing it to those

dimensions.  If the new grid is bigger, incoming data is repeated to fill the

grid; if  the new grid is smaller, extra data is dropped. </p>



<p>ex: with a 240 320 RGB image, @redim 120 640 3 will visually separate  the

even lines (left) from the odd lines (right). contrary to this, @redim  640 120

3 will split every line and put its left half on a even line and the right half

on the following odd line. @redim 480 320 3 will repeat the input image twice

in the output image. @redim 240 50 3 will only keep  the 50 top lines.</p>



	

	

	<tr><td colspan="4"><h5><a name="@store">@store</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@store.jpg"><br clear="left"><br><br><a href="images/grab_cross_fade.png"><img src="images/ic_grab_cross_fade.jpg" border="0"></a></td><td>

		



		<p>A @store object can store exactly one Grid. You store it via its

right  inlet. You fetch it by sending a bang through its left inlet, which

sends  the Grid on the outlet. You may also perform all kinds of coordinate

transforms  with @store. You send in the left inlet a Grid whose two channels

are  Y and X coordinates of pixels of the stored grid. Values too large or  too

small are wrapped around (using uniform modulo). @store is even more  flexible

than that: you can address whole lines and pixel parts too, by  sending

appropriately-sized grids (non-3D). Advanced users can figure  it out;

beginners should simply ignore it. </p>



		<p>If you send to @store a grid of 2 dimensions consisting of rows (y)

and  channels, in which the channel ... see the example</p>



		<p>TODO @store takes one argument specifying its size, int32 (default)

or  uint8 (native format for ppm or tga formats) </p>



		

	

	<tr><td colspan="4"><h5><a name="@outer">@outer</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@outer.jpg"><br clear="left"><br><br><a href="images/grab_outer.png"><img src="images/ic_grab_outer.jpg" border="0"></a></td><td>

		

		<p>When given a grid of Dim(3) and a grid of Dim(5) [@outer] will produce 

		a grid of Dim(3,5) with the selected binary operation applied on each 

		of the possible pairs combinations between numbers from the left grid 

		and the ones from the right. for example : (10,20,30) [@outer +] (1,2,3) 

		will give : ((11,12,13),(21,22,23),(31,32,33)) </p>

		

	



	<tr><td colspan="4"><h5><a name="@!">@!</a></h5></td></tr><tr><td></td><td valign='top'><br><br clear="left"><br><br></td><td>

	

	



	<tr><td colspan="4"><h5><a name="@">@</a></h5></td></tr><tr><td></td><td valign='top'><br><br clear="left"><br><br><a href="images/grab_binary_operations.png"><img src="images/ic_grab_binary_operations.jpg" border="0"></a></td><td>

		<p>This object computes a Grid by combining each of its elements with an 

		integer in its right inlet. This is not unlike built-in arithmetic objects, 

		except that the left inlet, and the outlet, work with Grids. This runs 

		up to 10 times faster than equivalent built-ins (but still probably slower 

		than equivalent DSP built-ins. Construction takes 2 parameters: a first 

		one is the operation's symbol, and a second optional one is the default 

		value for the right inlet. Operations provided are listed below in the 

		"binary operations" section. Many of them have no equivalent 

		in "plain jMax". 

		</p>

	

		

	

<tr><td>&nbsp;</td></tr>



<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><h4>Reporting Objects</h4></td></tr>

	<tr><td colspan="4"><h5><a name="@dim">@dim</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@dim.jpg"><br clear="left"><br><br><a href="images/grab_dim.png"><img src="images/ic_grab_dim.jpg" border="0"></a></td><td>

		

		<p>Returns list of dimensions as a grid. Given a grid sized like Dim(240,320,4), 

		@dim will return a grid like Dim(3), whose values are 240, 320, 4. </p>

		

	

<tr><td>&nbsp;</td></tr>



<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><h4>Special Objects</h4></td></tr>

	<tr><td colspan="4"><h5><a name="rtmetro">rtmetro</a></h5></td></tr><tr><td></td><td valign='top'><br><br clear="left"><br><br></td><td>

		future use.

	

	<tr><td colspan="4"><h5><a name="@global">@global</a></h5></td></tr><tr><td></td><td valign='top'><br><br clear="left"><br><br></td><td>

		objects of this class do nothing by themselves and are just

		an access point to features that don't belong to any object in

		particular.

		<br><b>method</b> profiler_reset <b>(</b><b>)</b>

			resets all the time counters.

		<br><br>

		<br><b>method</b> profiler_dump <b>(</b><b>)</b>

			displays the time counters in decreasing order, with

			the names of the classes those objects are in. this is

			an experimental feature. like most statistics,

			it could be vaguely relied upon if

			only you knew to which extent it is unreliable. more on this

			in a future section called "profiling".

		<br><br>

	

<tr><td>&nbsp;</td></tr>



<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><h4>Compound Objects</h4></td></tr>

	<tr><td colspan="4"><h5><a name="@contrast">@contrast</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@contrast.jpg"><br clear="left"><br><br><a href="images/grab_contrast.png"><img src="images/ic_grab_contrast.jpg" border="0"></a></td><td>

		



		<p>@contrast adjusts the intensity in an image.

		values outside 0-255 are automatically trimmed. </p>



		<p> Sending an integer to inlet 2 sets the intensity of incoming

		white to a certain fraction between output black and output white.

		normal value is 256; may be set smaller or bigger.</p>



		<p> Sending an integer to inlet 1 sets the intensity of incoming

		black to a certain fraction between output black and inlet 2 value.

		normal value is 256; may be set smaller or bigger.</p>



		<p> Sending a grid to inlet 0 filters it to outlet 0.</p>



		 





<tr><td colspan="4"><h5><a name="@identity_transform">@identity_transform</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@identity_transform.jpg"><br clear="left"><br><br><a href="images/grab_identity_transform.png"><img src="images/ic_grab_identity_transform.jpg" border="0"></a></td><td>

	

<p>@identity_transform builds a pixel-level transform grid suitable for 

using with inlet 0 of @store. </p>

<p> Sending an integer to inlet 2 sets the width of the resulting picture.</p>

<p> Sending an integer to inlet 1 sets the height of the resulting picture.</p>

<p> Sending a grid to inlet 0 generates said grid and sends it to inlet 

0. Not guaranteed to be fast (use an intermediate @store as a cache 

if needed)</p>



	





<tr><td colspan="4"><h5><a name="@posterize">@posterize</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@posterize.jpg"><br clear="left"><br><br><a href="images/grab_posterize.png"><img src="images/ic_grab_posterize.jpg" border="0"></a></td><td>

	

<p>@posterize reduces the number of intensities in an image. </p>

<p> Sending an integer to inlet 1 sets the number of possible levels. 

Minimum value is 2. Simulate 216-color palette with 6. Simulate 15-bit 

depth with 32. The effect is mostly apparent with small values.</p>

<p> Sending a grid to inlet 0 filters it to outlet 0.</p>

	





<tr><td colspan="4"><h5><a name="@scale_to">@scale_to</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@scale_to.jpg"><br clear="left"><br><br><a href="images/grab_scale_to.png"><img src="images/ic_grab_scale_to.jpg" border="0"></a></td><td>

	

<p>@scale_to is normally fed the same inlet 1,2 values as @identity_transform, 

and chained from @identity_transform and to @store. This will scale an 

image of any size to the size specified in inlets 1,2. If it doesn't correspond 

the values of @identity_transform, part of the image will be trimmed and/or 

duplicated.</p>



	





<tr><td colspan="4"><h5><a name="@spread">@spread</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@spread.jpg"><br clear="left"><br><br><a href="images/grab_spread.png"><img src="images/ic_grab_spread.jpg" border="0"></a></td><td>

	

<p>@spread scatters the pixels in an image. Not all original pixels will 

appear, and some may get duplicated (triplicated, etc) randomly. Some 

wrap-around effect will occur close to the edges. </p>

<p> Sending an integer to inlet 1 sets the amount of spreading in maximum 

number of pixels + 1. even values translate the whole image by half 

a pixel due to rounding.</p>

	





<tr><td colspan="4"><h5><a name="@three">@three</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@three.jpg"><br clear="left"><br><br></td><td>

	

<p>@three builds a Dim(3) grid using integers sent in inlets 0, 1, 2. </p>

<p>Sending an integer guarantees an update to outlet 0 (currently it's 

doing redundant updates -- sorry)</p>





<tr><td colspan="4"><h5><a name="@two">@two</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/@two.jpg"><br clear="left"><br><br><a href="images/grab_two.png"><img src="images/ic_grab_two.jpg" border="0"></a></td><td>



<p>@two builds a Dim(2) grid using integers sent in inlets 0, 1. </p>

<p>Sending an integer guarantees an update to outlet 0 (currently it's 

doing redundant updates -- sorry)</p>





<tr><td>&nbsp;</td></tr>



<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><h4>Unary Operators</h4></td></tr>



	



	<tr><td></td><td></td><td><table border='1'><tr><td><img src="images/@!_abs.jpg" border="0"></td><td>

		absolute value of A

	</td></tr>

	<tr><td><img src="images/@!_rand.jpg" border="0"></td><td>

		produces an random number between 0 and A-1

	</td></tr>

	<tr><td><img src="images/@!_sqrt.jpg" border="0"></td><td>

		square root of A, rounded downwards

	</td></tr>

<tr><td>&nbsp;</td></tr></table>



<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><h4>Binary Operators</h4></td></tr>

	<tr><td></td><td></td><td><p>where A is the left value, and B is the right value.</p></td></tr>



	

	



	

	<tr><td></td><td></td><td><table border='1'><tr><td><img src="images/@_%2B.jpg" border="0"></td><td>

		A + B

	</td></tr>

	<tr><td><img src="images/@_-.jpg" border="0"></td><td>

		A - B

	</td></tr>

	<tr><td><img src="images/@_inv%2B.jpg" border="0"></td><td>

		B - A

	</td></tr>



	

	<tr><td><img src="images/@_x.jpg" border="0"></td><td>

		A * B

	</td></tr>

	<tr><td><img src="images/@_division.jpg" border="0"></td><td>

		A / B, rounded downwards

	</td></tr>

	<tr><td><img src="images/@_invx.jpg" border="0"></td><td>

		B / A, rounded downwards

	</td></tr>

	<tr><td><img src="images/@_modulo.jpg" border="0"></td><td>

		A % B, non-negative remainder

	</td></tr>

	<tr><td><img src="images/@_swap.jpg" border="0"></td><td>

		B % A, non-negative remainder

	</td></tr>



	

	<tr><td><img src="images/@_a_or_b_bitwise.jpg" border="0"></td><td>

		A or B, bitwise

	</td></tr>

	<tr><td><img src="images/@_xor_bitwise.jpg" border="0"></td><td>

		A xor B, bitwise

	</td></tr>

	<tr><td><img src="images/@_and.jpg" border="0"></td><td>

		A and B, bitwise

	</td></tr>

	<tr><td><img src="images/@_shift_bits_left.jpg" border="0"></td><td>

		A * (2**(B % 32)), which is left-shifting

	</td></tr>

	<tr><td><img src="images/@_shift_bits_right.jpg" border="0"></td><td>

		A / (2**(B % 32)), which is right-shifting

	</td></tr>



	

	<tr><td><img src="images/@_if_then_else.jpg" border="0"></td><td>

		if A is zero then B else A

	</td></tr>

	<tr><td><img src="images/@_&&.jpg" border="0"></td><td>

		if A is zero then zero else B

	</td></tr>

	<tr><td><img src="images/@_min.jpg" border="0"></td><td>

		the lowest value in A,B

	</td></tr>

	<tr><td><img src="images/@_max.jpg" border="0"></td><td>

		the highest value in A,B

	</td></tr>



	

	<tr><td><img src="images/@_comp.jpg" border="0"></td><td>

		-1 when A<B; 0 when A=B; 1 when A>B.

	</td></tr>

	<tr><td><img src="images/@_equals.jpg" border="0"></td><td>

		is A equal to B ? 1=true, 0=false

	</td></tr>

	<tr><td><img src="images/@_not_equal.jpg" border="0"></td><td>

		is A not equal to B ?

	</td></tr>

	<tr><td><img src="images/@_greater_than.jpg" border="0"></td><td>

		is A greater than B ?

	</td></tr>

	<tr><td><img src="images/@_smaller_or_equal.jpg" border="0"></td><td>

		is A not greater than B ?

	</td></tr>

	<tr><td><img src="images/@_smaller_than.jpg" border="0"></td><td>

		is A less than B ?

	</td></tr>

	<tr><td><img src="images/@_larger_or_equal_to.jpg" border="0"></td><td>

		is A not less than B ?

	</td></tr>



	

	<tr><td><img src="images/@_sin.jpg" border="0"></td><td>

		B * sin(A), where A is in hundredths of degrees

	</td></tr>

	<tr><td><img src="images/@_cos.jpg" border="0"></td><td>

		B * cos(A)

	</td></tr>

	<tr><td><img src="images/@_atan.jpg" border="0"></td><td>

		arctan(A/B)

	</td></tr>

	<tr><td><img src="images/@_tanh.jpg" border="0"></td><td>

		tanh(A) where A is in hundredths of degrees (yes, really)

	</td></tr>

	<tr><td><img src="images/@_gamma.jpg" border="0"></td><td>

		floor(pow(a/256.0,256.0/b)*256.0)

	</td></tr>

	<tr><td><img src="images/@_xx.jpg" border="0"></td><td>

		A raised to power B

	</td></tr>

<tr><td>&nbsp;</td></tr></table>



<tr> 
<td colspan="4" bgcolor="black"><img src="images/black.png" width="1" height="2"></td>
</tr>
<tr><td colspan="4"><h4>External Picture Formats</h4></td></tr>



	<tr><td colspan="4"><h5><a name="format ppm @in/@out">format ppm @in/@out</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/open_ppm.jpg"><br clear="left"><br><br></td><td>

		

		Subformat P6 only.

		Max number 255 (24-bit RGB).

	



	<tr><td colspan="4"><h5><a name="format targa @in">format targa @in</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/open_tga.jpg"><br clear="left"><br><br></td><td>

		

		<p>Support for RGB-24 (3 channels).</p>

		<p>If you bug me a bit you'll get ARGB-32 too.</p>

	



	<tr><td colspan="4"><h5><a name="format videodev @in">format videodev @in</a></h5></td></tr><tr><td></td><td valign='top'><br><img src="images/open_videodev.jpg"><br clear="left"><br><br></td><td>

		



		<p>Video4Linux-1 devices, RGB-24 only. Variable picture size.

		should work for bttv based cards and the dc1 from miro, possibly 

		dc10plus.</p>



		<p>If you suffer from color inversion, you may feed the list

		"<kbd>0 0 1 0 1 0 1 0 0</kbd>" to a [@redim 3 3] and feed that to the

		right side of a <kbd>[@inner * + 0]</kbd>. Use that @inner object as a

		RGB-BGR converter.</p>



		<p>color adjustments:

		<ul>

		<li><b>1</b> : <kbd>brightness</kbd> <i>integer</i></li>

		<li><b>2</b> : <kbd>hue</kbd> <i>integer</i></li>

		<li><b>3</b> : <kbd>colour</kbd> <i>integer</i></li>

		<li><b>4</b> : <kbd>contrast</kbd> <i>integer</i></li>

		<li><b>5</b> : <kbd>whiteness</kbd> <i>integer</i></li>

		</ul></p>



		<p>other options:

		<ul>

		<li><b>1</b> : <kbd>channel</kbd> <i>integer</i></li>

		<li><b>2</b> : <kbd>tuner</kbd> <i>integer</i></li>

		<li><b>3</b> : <kbd>norm</kbd> <i>integer</i></li>

		</ul></p>



			<br><b>method</b> option size <b>(</b>height<b>,</b>width<b>)</b>

				

				

				sets the input size, especially when using a video digitalizer

				device

			<br><br>



	



	<tr><td colspan="4"><h5><a name="format x11 @in/@out">format x11 @in/@out</a></h5></td></tr><tr><td></td><td valign='top'><br><img src=""><br clear="left"><br><br><a href="images/grab_video_out.png"><img src="images/ic_grab_video_out.jpg" border="0"></a></td><td>



		



		<br><b>method</b> open x11 here <b>(</b><b>)</b>

			connects to the default X11 server,

			according to your environment variable "DISPLAY".

		<br><br>



		<br><b>method</b> open x11 local <b>(</b>display_number<b>)</b>

			

			connects to a display server on this machine.

		<br><br>

		

		<br><b>method</b> open x11 remote <b>(</b>host_name<b>,</b>display_number<b>)</b>

			

			

			connects to a remote X11 display server using TCP.

			Sorry, IP addresses are not supported (jMax limitation).

			Port number will be 6000 plus the display number, because

			of the X11 standard.

		<br><br>

		

		<br><b>grid</b> <b>dim(</b>rows columns {red green blue}<b>)</b>

			resizes the window to the size of the grid;

			encodes that grid in the display's pixel format;

			also displays it if autodraw > 0

			the values must be in range 0-255,

			or else they will be "wrapped".

		<br><br>



		<br><b>method</b> bang <b>(</b><b>)</b>

			see format x11's option draw.

		<br><br>



		<br><b>method</b> autodraw <b>(</b><b>)</b>

			

			see format x11's option autodraw.

		<br><br>



		<p>

		Destroying the object (or sending "close") should close the window.

		Because of how jMax works,

		this may be delayed until you do something else.

		</p>



		<p>because of the design of Xlib, or if any of the connections

		involved crashes, then the whole program (fts) has to be terminated.

		(don't you love xlib). Something similar happens if you close any

		of the windows yourself, but IIRC this could be fixed.</p>



		<p>only one window may be used per connection (to simplify matters;

		this doesn't reduce flexibility).</p>



		<p>there is an additional argument that may be added to every

		"open" message; if you don't put it, a new toplevel window is created.

		if you put "root" then the screen's wallpaper will be used instead

		(it may fail to work with some popular window managers). You can also

		put a window number, e.g. <kbd>0x28003ff</kbd>, you may connect to

		an existing window; you can find out the number of a window by using

		a tool like <kbd>xwininfo</kbd>, part of X11 standard tools.</p>



		<br><b>method</b> option out_size <b>(</b>height<b>,</b>width<b>)</b>

			

			

			changes the window's size, just like sending a grid

			dim(height,width,3) would.

		<br><br>

		

		<br><b>method</b> option draw <b>(</b><b>)</b>

			forces a redraw of the window's contents.

		<br><br>



		<br><b>method</b> option autodraw <b>(</b>level<b>)</b>

			

			<ul>

			<li><b>0</b> : option draw() is never automatically invoked</li>

			<li><b>1</b> : option draw() is invoked after each grid is finished</li>

			<li><b>2</b> : option draw() is invoked incrementally after each row is

			received. (but buffering may cause lines to come in groups

			anyway)</li>

			</ul>

		<br><br>



		

	



<tr><td>&nbsp;</td></tr>

</table>
</body>
</html>


